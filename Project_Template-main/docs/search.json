[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Although renewable energy is crucial to meeting Taiwan’s Net Zero goals, land availability represents a critical constraint (Hsiao et al., 2021). To address this, the Taiwanese government has implemented an aquavoltaics programme, integrating solar panels into fish farms to generate space-efficient energy. However, this initiative faces significant local opposition, with some authorities even banning construction due to concerns about socio-environmental impacts such as temperature increases, known as the photovoltaic heat island effect (PHVI). There is a clear need for an accessible, evidence-based participatory planning tool to resolve local conflicts, overcome planning roadblocks, and provide a foundation for informed programme expansion.\n\n\n\n\n\n\n\nThis application serves as a participatory planning tool to overcome conflicts between stakeholders with opposing perspectives on aquavoltaic expansion. It does this by openly exploring the PHVI impacts of past and prospective solar farms sites. Alongside expediting planning, helping mitigate local impacts, and supporting Taiwan’s Net Zero goals, additional benefits for each stakeholder are outlined below:\n\nNational government: communicating policy; mitigating unfounded concerns.\nLocal government: evidence-based assessment of past projects; informed future planning within jurisdictions.\nFish farmers: presenting a case for having solar panels installed on their sites.\nLocal residents: reducing concerns; empowering them to challenge decisions at higher governance levels.\n\n\n\n\n\nLandsat 8 Collection 1 Top of Atmosphere imagery at 30m resolution for temperature change assessments.\nSentinel-2 imagery at 10m resolution for fish farm identification.\nSolar panel polygons and construction dates from the Taiwanese Civil Service..\nPopulation estimates at 30m resolution from Meta’s Data for Good\nDigital elevation data at 30m resolution from the NASA Shuttle Radar Topography Mission.\n\n\n\n\nFirst, land surface temperature (LST) before and after solar panel installation is calculated using the method detailed by Xu et al., (2024), which averages satellite images for a period of three years before and after construction of the solar panel. A random forest model uses these changes, alongside optical and thermal imagery, slope, and elevation to predict temperature impacts at other sites. A second random forest identifies fish farms, ensuring users can only select prospective sites which could be included in the programme. Finally, predicted temperature change and local population estimates indicate the impact of developments on local communities.\n\n\n\nThe application provides a transparent, accessible tool to foster communication, improve collaboration, and bring clarity to a contentious issue. The interface is divided into two: the Explore tab provides a broad overview of PHVI impacts through summary statistics and charts, while the Predict tab enables site-specific predictions, allowing users to tailor insights to their local context. Users can click on solar farms to receive a summary at any point, either supplementing the overview or facilitating comparisons with prospective sites. A blue-to-red colour scheme intuitively communicates temperature changes, and clear chart titles and disclaimers ensure the analysis is understandable and transparent.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst, the data collection is filtered with a 25% cloud cover threshold and mean pixel values are calculated for a period of 3 years pre- and post-construction of the solar panel. LST is calculated using the following equation: LST = (BT / (1 + (0.00115 * (BT / 1.4388)) * Ln(ε))) found in the USGS handbook (2019). Other indices like NDVI and NDBI are also calculated in this step for the prediction model.\n// ------ LST Calculations ------\n\nfunction getLST(geom, start, end) {\n  var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n    .filterBounds(geom)\n    .filterDate(start, end)\n    .filter(ee.Filter.lt('CLOUD_COVER',25));\n\n  var lstCollection = collection.map(function(img) {\n    var ndvi = img.normalizedDifference(['B5', 'B4']).rename('NDVI');\n    var fv = ndvi.subtract(0).divide(1 - 0).rename('FV');\n    var em = fv.multiply(0.004).add(0.986).rename('EM');\n    var thermal = img.select('B10');\n    var lst = thermal.expression(\n      '(Tb / (1 + (0.00115 * (Tb / 1.438)) * log(Ep))) - 273.15',\n      {\n        'Tb': thermal,\n        'Ep': em\n      }\n    ).rename('LST');\n\n    //Extra variables for the random forest: optical bands, thermal bands, NDBI, and NDVI, FV, EM\n    var optical = img.select(['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']);\n    var thermalBands = img.select(['B10', 'B11']);\n    var ndbi = img.normalizedDifference(['B6', 'B5']).rename('NDBI');\n    return lst.addBands([ndvi, fv, em, ndbi]).addBands(optical).addBands(thermalBands).copyProperties(img, img.propertyNames());\n  });\n\n  var mean = ee.Image(lstCollection.mean());\n  var bands = mean.bandNames();\n  var hasLST = bands.contains('LST');\n  return ee.Algorithms.If(hasLST, mean.clip(geom), ee.Image().rename('LST').clip(geom));\n}\n\n// Calculate LST for all polygons\nfunction calculateLST(feature) {\n  var dateString = ee.String(feature.get('dateright'));\n  var parts = dateString.split('-');\n  var year = ee.Number.parse(parts.get(0));\n  var month = ee.Number.parse(parts.get(1));\n  var day = ee.Number.parse(parts.get(2));\n  var constructDate = ee.Date.fromYMD(year, month, day);\n\n  var preStart = constructDate.advance(-3, 'year');\n  var preEnd = constructDate;\n  var postStart = constructDate.advance(1, 'year');\n  var postEnd = constructDate.advance(4, 'year');\n\n  var geom = feature.geometry();\n  var preImage = ee.Image(getLST(geom, preStart, preEnd));\n  var postImage = ee.Image(getLST(geom, postStart, postEnd));\n  var diff = postImage.select('LST').subtract(preImage.select('LST')).rename('LST_Difference');\n\n  // Reducers for LST calculations\n  var meanPreLSTDict = preImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanPostLSTDict = postImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanDiffDict = diff.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n\n  // Reducers for other indices for RF\n  var preOpticalDict = preImage.select(['NDVI', 'FV', 'EM', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: geom,\n    scale: 30,\n    maxPixels: 1e13\n  });\n\n  var meanPreLST = ee.Algorithms.If(meanPreLSTDict.contains('LST'), meanPreLSTDict.get('LST'), null);\n  var meanPostLST = ee.Algorithms.If(meanPostLSTDict.contains('LST'), meanPostLSTDict.get('LST'), null);\n  var meanDiff = ee.Algorithms.If(meanDiffDict.contains('LST_Difference'), meanDiffDict.get('LST_Difference'), null);\n\n  return feature.set({\n    'mean_preLST': meanPreLST,\n    'mean_postLST': meanPostLST,\n    'mean_LST_diff': meanDiff\n  }).set(preOpticalDict).setGeometry(feature.geometry());\n}\nvar results = polygons.map(calculateLST);\nGiven local government and resident concerns about PHVI’s impact on surrounding communities, we define a function called popBuffer to sum estimated populations within 730 metres of solar farms: a distance typically affected by PHVI (Guoqing et al., 2021).\n//Load population from Data For Good\nvar HRSL_total = ee.ImageCollection('projects/sat-io/open-datasets/hrsl/hrslpop').filterBounds(taiwan).median();\n\n//Vulnerable population: sum of 0-5 and 60+\nvar HRSL_0_5 = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_children_under_five\").filterBounds(taiwan).median();\nvar HRSL_60plus = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_elderly_over_sixty\").filterBounds(taiwan).median();\nvar HRSL_vulnerable = HRSL_0_5.add(HRSL_60plus).rename('HRSL_vulnerable');\n\n//Calculate population within 730m buffer\nfunction popBuffer(panel) {\n  var geom = panel.geometry().buffer(730);\n  var totalPop = ee.Number(HRSL_total.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('b1')).round();\n  var vulnerablePop = ee.Number(HRSL_vulnerable.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('HRSL_vulnerable')).round();\n  return panel.set({'total_buffer_pop': totalPop, 'vulnerable_buffer_pop': vulnerablePop});\n}\nvar all_results = results.map(popBuffer);\nFinally, due to their impact on LST (Šafanda, 1999), we load slope and elevation data and reduce these to the means for each solar polygon. We also calculate polygon areas in hectares.\n//Add extra non-Landsat features: elevation, topography, and polygon area\nvar srtm = ee.Image('USGS/SRTMGL1_003').clip(taiwan);\nvar elevation = srtm.select('elevation');\nvar slope = ee.Terrain.slope(srtm);\n\nvar allFeatures = validFeatures.map(function(feature) {\n  var geom = feature.geometry();\n  var meanElevation = elevation.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('elevation');\n  var meanSlope = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('slope');\n  var area = geom.area().divide(10000); //converting to ha as metres were overwhelming the model\n  return feature.set({\n    'elevation': meanElevation,\n    'slope': meanSlope,\n    'area': area});\n});\n\n\n\nAfter filtering all polygons to ensure they contain the necessary data, variables were extracted to conduct principal component analysis in Python to reduce dimensionality and prevent multicollinearity. The resultant random forest model is trained on 70% of the polygons, and has an R^2 of 0.79. It has a low RMSE and MAE relative to average temperature change, making it suitable for predicting changes in new sites.\n//Extract training data\nvar bands = test.select(['mean_preLST', 'mean_postLST', 'mean_LST_diff', 'NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area'])\n  .randomColumn();\n\n//Define test-train split\nvar split=0.7\nvar training_sample = bands.filter(ee.Filter.lt('random', split));\nvar validation_sample = bands.filter(ee.Filter.gte('random', split));\n\nprint('Sample training feature:', training_sample.first())\n\n//Set up RF\nvar model = ee.Classifier.smileRandomForest(100)\n  .setOutputMode('REGRESSION')\n  .train({\n    features: training_sample,\n    classProperty: 'mean_postLST',\n    //removed mean_preLST, EM, FV due to multicollinearity\n    inputProperties: ['NDVI', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area']});\nIf users are to select potential aquavoltaic installation sites, it is imperative that these are actually fish farms. We used a random forest model to identify existing fish farms based on Sentinel-2 imagery, drawing from Ballinger’s (2024) oil refinery identification. The model is trained and tested on manually drawn land identification polygons. The resulting prediction data was then manually cleaned in QGIS. In the prediction tab of the final application, the user’s polygon selection is required to intersect with a fish farm. While the model is not perfectly accurate, it sufficiently limits user input to areas with fish farms.\n\n// pre-process imagery\nvar start='2021-04-14';\nvar end='2025-04-14';\nvar bands = ['B2', 'B3', 'B4','B5','B6','B7','B8', 'B8A','B11','B12'];\n\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n                \nvar s_rgb = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nvar sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n  .filterBounds(AOI)\n  .filterDate(start, end)\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n  .select('VV')\n  .mean();\n\nvar ndvi=sentinel.normalizedDifference(['B8','B4']).select(['nd'],['ndvi']);\nvar ndwi=sentinel.normalizedDifference(['B3','B8']).select(['nd'],['ndwi'])\nvar newBands = ee.Image([ndwi,ndvi,sentinel1.rename('S1_VV')]);\nvar image=sentinel.addBands(newBands).clip(AOI);\n\n// add AOI and satellite imagery to map\nMap.addLayer(image.clip(AOI), s_rgb, 'Sentinel');\nMap.addLayer(AOI,null,\"AOI\",false);\n\n// select random points from each land type for training/validation\nvar fishfarm_points=ee.FeatureCollection.randomPoints(fishfarms, 3000).map(function(i){\n  return i.set({'class': 0})});\n  \nvar urban_points=ee.FeatureCollection.randomPoints(urban, 1000).map(function(i){\n  return i.set({'class': 1})});\n\n  \nvar river_points=ee.FeatureCollection.randomPoints(rivers, 2000).map(function(i){\n  return i.set({'class': 2})});  \n\nvar sample=ee.FeatureCollection([urban_points,\n                                  fishfarm_points,\n                                  river_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();\n\n// take samples from image for training and validation   \nvar split=0.7\nvar training_sample = sample.filter(ee.Filter.lt('random', split));\nvar validation_sample = sample.filter(ee.Filter.gte('random', split));\n\nvar training = image.sampleRegions({\n  collection: training_sample,\n  properties: ['class'],\n  scale: 10,\n});\n\nvar validation = image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// create model and run to create predictions\nvar model = ee.Classifier.smileRandomForest(400)\n.train(training, 'class');\n\nvar prediction = image.classify(model);\n\nvar fishfarm_prediction=prediction.updateMask(prediction.eq(0));\n\nMap.addLayer(fishfarm_prediction,{palette:'red'},'Predicted Fish Farms');\n\n// Assess accuracy of model\nvar validated = validation.classify(model);\n\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\nprint('Confusion Matrix ', testAccuracy);\nprint('Validation overall accuracy: ', testAccuracy.accuracy())\n\n\n\n\n\n\nThis code builds an interactive user interface (UI) in Google Earth Engine. It structures the app into two main parts: a Main Panel and a Map. The Main Panel includes two navigation buttons (to switch between exploring existing solar farms or predicting impacts for new sites), and a content container that updates to show either statistics, charts, and layer controls, or drawing tools for prediction.\n/*\nRoot\n├── Main Panel\n│   ├── Title\n│   ├── Button Panel\n│   │   ├── Visualize Button\n│   │   └── Predict Button\n│   └── Content Container\n│       ├── Visualize Content\n│       │   ├── Statistics Cards\n│       │   ├── Charts\n│       │   └── Layer Controls\n│       └── Predict Content\n│           ├── Drawing Tools\n│           └── Results Panel\n└── Map\n    ├── Base Layer\n    ├── Solar Panels Layer\n    ├── Fish Farms Layer\n    └── Population Layer\n*/\n\n// Clear UI and define core functions\nui.root.clear();\n\n// Initialize main UI components\nvar mainPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {width: '500px', padding: '10px'}\n});\n\nvar map = ui.Map();\nmap.setOptions('SATELLITE');\nmap.setCenter(120.10159388310306, 23.119258878572882, 13.5)\n\n//Add a legend\nvar legend = ui.Panel({style: {position: 'bottom-left', padding: '8px 15px'}});\nvar legendTitle = ui.Label({value: 'Temperature Difference (°C)', style: {fontWeight: 'bold', fontSize: '14px', margin: '0 0 4px 0'}});\nlegend.add(legendTitle);\n//Set visualisation parameters - same as polygons\nvar palette = palettes.colorbrewer.RdBu[9].reverse();\nvar min = -6;\nvar max = 6;\n//Set up colour bar\nvar colorBar = ui.Thumbnail({image: ee.Image.pixelLonLat().select(0).multiply((max - min) / 100.0).add(min)\n           .visualize({min: min, max: max, palette: palette}),\n  params: {bbox: [0, 0, 100, 10], dimensions: '100x10'},\n  style: {stretch: 'horizontal', margin: '0px 8px', maxHeight: '24px'}\n});\nlegend.add(colorBar);\n//Add labels\nvar legendLabels = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {margin: '1px 0 0 0'}\n});\nlegendLabels.add(ui.Label(min.toString(), {fontSize: '12px'}));\nlegendLabels.add(ui.Label(' ', {stretch: 'horizontal'})); // Spacer\nlegendLabels.add(ui.Label(max.toString(), {fontSize: '12px'}));\nlegend.add(legendLabels);\nmap.add(legend);\n\n// Create UI panels and buttons\nmainPanel.add(ui.Panel({\n  widgets: [ui.Label('Tainan Solar Farm Heat Impact App', \n    {fontWeight: 'bold', fontSize: '22px', margin: '0 0 10px 0', padding: '6px'})],\n  style: {padding: '0'}\n}));\n\n// Content panels\nvar visualizeContent = ui.Panel({style: {border: '1px solid #999', padding: '8px'}});\nvar predictedContent = ui.Panel({\n  widgets: [ui.Label('Still working', {fontSize: '16px', padding: '20px'})],\n  style: {border: '1px solid #999', padding: '8px'}\n});\n\n// Navigation buttons\nvar buttons = {\n  visualize: ui.Button({\n    label: 'Explore Existing Solar Farms',\n    onClick: function() {\n      showPanel(visualizeContent, buttons.visualize, buttons.predict);\n    },\n    style: {padding: '4px', fontWeight: 'bold', \n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  }),\n  predict: ui.Button({\n    label: 'Predict Change in a New Site',\n    onClick: function() {\n      showPanel(predictedContent, buttons.predict, buttons.visualize);\n    },\n    style: {padding: '4px', fontWeight: 'bold',\n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  })\n};\n// Button panel and container\nvar buttonPanel = ui.Panel([buttons.visualize, buttons.predict], \n  ui.Panel.Layout.flow('horizontal'), {margin: '0 0 20px 0'});\nvar contentContainer = ui.Panel();\n\n\n\nThis code builds a visualization interface to analyze solar farm impacts. It features three toggleable layers (solar panels, fish ponds, population estimates) managed by layerConfigs and createLayerControl. It displays solar farm counts, installation dates, statistic cards, and three charts. Users can interactively click farms for details and customize visible data through the control panel.\n//Set solar panel visualisation parameters\nvar solarStyle = {min: -6, max: 6, palette: palettes.colorbrewer.RdBu[9]}; //for some reason we don't reverse it bc we've already reversed the legend!\n\n//Reduce to image for faster loading\nvar solarImage = results.reduceToImage({properties: ['mean_LST_diff'], reducer: ee.Reducer.mean()}).rename('mean_LST_diff');\n\n//Add outlines so users can later select polygons\nvar outlinedPolygons = results.style({color: 'black', fillColor: '00000000', width: 0.5});\nMap.addLayer(outlinedPolygons, {}, 'Polygon Outlines');\n\n// define layerConfigs\nvar layerConfigs = {\n  'Solar Panels': {\n    layer: solarImage,\n    defaultVisible: true,\n    visParams: solarStyle,\n    type: 'raster'\n  },\n  \n  'Fish Farms': {\n    layer: fishfarms,\n    defaultVisible: false,\n    visParams: {\n      color: 'blue',\n      fillColor: '#87CEEB88',\n      width: 0\n    },\n    type: 'vector'\n  },\n  'Population Estimates': {\n    layer: HRSL_total, //.select('b1'),\n    defaultVisible: false,\n    visParams: {\n      min: 0,\n      max: 16,\n      palette: ['#A902A9'], //just a single colour, we don't want to complicate visualisation by having different pop colours too\n      opacity: 0.5},\n    type: 'raster'}\n};\n\n// define layer cache\nvar layerCache = {};\n\n// define layer order for UI display\nvar uiLayerOrder = [\n  'Solar Panels',\n  'Fish Farms',\n  'Population Estimates'\n];\n\n// define layer order for map display\nvar layerOrder = {\n  'Fish Farms': 1,\n  'Population Estimates': 2,\n  'Solar Panels': 3\n};\n\n//Add general instructions first\nvisualizeContent.add(ui.Label('Welcome!', {fontWeight:'bold', fontSize:'18px'}));\nvisualizeContent.add(ui.Label(\n  'This app uses satellite imagery to explore how solar farms influence local temperatures and communities.\\n\\n' +\n  'Use the map and this Explore tab to get a broad understanding of solar farm impacts. Click on a solar farm on the map to get more information about it. Finally, visit the Prediction tab to assess the potential effects of building a new solar farm in a location of your choice.',\n  {whiteSpace: 'pre-line'}\n));\n\n// add layer control to visualizeContent\nvisualizeContent.add(ui.Label('Select Data to Display:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\nuiLayerOrder.forEach(function(layerName) {\n  visualizeContent.add(createLayerControl(layerName));\n});\n\n// add Summary Statistics panel\nvisualizeContent.add(ui.Label('Overview:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n//Add total polygon numbers\nvar totalPanelsLabel = ui.Label('Loading total polygons count...', {\n  fontSize: '14px',\n  color: 'gray'});\nvisualizeContent.add(totalPanelsLabel);\n\ntotalPanels.evaluate(function(count) { //replace when calculated\n  visualizeContent.remove(totalPanelsLabel);\n  var boldLabel = ui.Label(String(count), {\n    fontSize: '15px', fontWeight: 'bold', color: 'black', padding: '0', margin: '0 4px 0 0'});\n  var regularLabel = ui.Label(' solar farms installed since March 2019.', {\n    fontSize: '15px', color: 'black', padding: '0', margin: '0'});\n  //Use a panel to make sure they're added next to each other\n  var labelPanel = ui.Panel({\n    widgets: [boldLabel, regularLabel],\n    layout: ui.Panel.Layout.flow('horizontal'),\n    style: {padding: '0', margin: '4px'}});\n  visualizeContent.widgets().insert(7, labelPanel); //make sure it's added in same position as before - ChatGPT helped\n});\n\n//Add summary statistics\nvar statCardsPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '10px 0'}\n});\n\n//Add a loading screen before the stats are calculated\nvar loadingCard = ui.Label('Loading maximum, minimum, and average temperature change...', {\n  fontSize: '14px',\n  color: 'gray',\n});\nstatCardsPanel.add(loadingCard);\n\nfunction createStatCard(label, value, color,textColor) {\n  return ui.Panel([\n    ui.Label(label, {\n      fontWeight: 'bold',\n      fontSize: '14px',\n      color: textColor,\n      backgroundColor: color\n    }),\n    ui.Label(value, {\n      fontSize: '18px',\n      color: textColor,\n      backgroundColor: color\n    })\n  ], ui.Panel.Layout.flow('vertical'), {\n    padding: '10px',\n    backgroundColor: color,\n    borderRadius: '8px',\n    margin: '4px',\n    width: '30%'\n  });\n}\n\n//Add Stat Cards in the order: min, max, average\nminTempChange.evaluate(function(min) {\n  statCardsPanel.clear(); //remove the loading bit\n  statCardsPanel.add(createStatCard('Min Temp Change', min.toFixed(2) + ' °C', '#2166ac','white'));\n  \n  averageTempChange.evaluate(function(avg) {\n    statCardsPanel.add(createStatCard('Avg Temp Change', avg.toFixed(2) + ' °C', '#f7f7f7','black'));\n\n    maxTempChange.evaluate(function(max) {\n      statCardsPanel.add(createStatCard('Max Temp Change', max.toFixed(2) + ' °C', '#b2182b','white'));\n    });\n  });\n});\nvisualizeContent.add(statCardsPanel);\n\n// add chart label and container\nvisualizeContent.add(ui.Label('Deeper Trends:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n// Create charts directly\nvar tempDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'mean_LST_diff',\n  minBucketWidth: 0.1\n}).setOptions({\n  title: 'What is the distribution of temperature change?',\n  hAxis: {title: 'Temperature Change (°C)'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#FE8789']\n});\n\nvar popDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'total_buffer_pop',\n  minBucketWidth: 50\n}).setOptions({\n  title: 'How many people typically live near a solar farm?',\n  hAxis: {title: 'Total Population Within 730m'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#A902A9']\n});\n\nvar nicerName = allFeatures.map(function(feature) { //improve appearance\n  return feature.set('Temperature Change (°C)', feature.get('mean_LST_diff'));\n});\n\nvar tempVsAreaChart = ui.Chart.feature.byFeature(\n  nicerName.filter(ee.Filter.notNull(['area', 'Temperature Change (°C)'])),\n  'area',\n  'Temperature Change (°C)'\n).setChartType('ScatterChart')\n .setOptions({\n   title: 'Is there a relationship between solar farm area and temperature?',\n   hAxis: {\n     title: 'Logged Area (hectares)',\n     scaleType: 'log',\n     format: 'short'\n   },\n   vAxis: {\n     title: 'Temperature Change (°C)',\n     viewWindow: {\n       min: -1,\n       max: 5\n     }\n   },\n   pointSize: 1,\n   colors: ['#ff8800'],\n   legend: {position: 'none'},\n   chartArea: {width: '85%', height: '80%'},\n   series: {0: {labelInLegend: 'Temp Change (°C)'}}\n });\n\n// Create a container for all charts\nvar chartsContainer = ui.Panel({\n  style: {margin: '10px 0'}\n});\n\n// Add charts to the container\nvisualizeContent.add(tempDistChart);\nvisualizeContent.add(popDistChart);\nvisualizeContent.add(tempVsAreaChart);\n\n\n//add disclaimer\nvisualizeContent.add(ui.Label(\n  'Please note that charts and summary statistics are based on a random sample of all solar farms. Although they closely reflect overall trends, exact values may vary slightly.',\n  {fontSize: '13px', fontStyle: 'italic'}));\n\n// then define createLayerControl function\nfunction createLayerControl(layerName) {\n  var config = layerConfigs[layerName];\n  \n  function createLayer() {\n    if (config.type === 'vector') {\n      return ui.Map.Layer({\n        eeObject: config.layer.style(config.visParams),\n        name: layerName,\n        shown: config.defaultVisible\n      });\n    }\n    return ui.Map.Layer({\n      eeObject: config.layer,\n      visParams: config.visParams,\n      name: layerName,\n      shown: config.defaultVisible\n    });\n  }\n\n  var checkbox = ui.Checkbox({\n    label: layerName,\n    value: config.defaultVisible,\n    onChange: function(checked) {\n      if (!layerCache[layerName]) {\n        layerCache[layerName] = createLayer();\n      }\n      \n      layerCache[layerName].setShown(checked);\n\n      // Add logic to link solar panel outlines (i.e. features) to the coloured panels (images) - ChatGPT helped here\n      if (layerName === 'Solar Panels') {\n        if (checked) {\n          layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n        } else {\n          layerCache['Polygon Outlines'] = null;\n        }\n      }\n\n      var visibleLayers = [];\n      // Sort layers by layerOrder\n      var sortedLayers = Object.keys(layerConfigs).sort(function(a, b) {\n        return layerOrder[a] - layerOrder[b];\n      });\n      \n      sortedLayers.forEach(function(name) {\n        if (layerCache[name] && layerCache[name].getShown()) {\n          visibleLayers.push(layerCache[name]);\n        }\n\n        //Again, ensure solar panel outlines are being shown if solar panels are\n        if (name === 'Solar Panels' && layerCache['Polygon Outlines']) {\n          visibleLayers.push(layerCache['Polygon Outlines']);\n        }\n      });\n\n      map.layers().reset(visibleLayers);\n    }\n  });\n\n  //Default load solar panel outlines, even though we don't want this to be shown in the UI\n  if (config.defaultVisible) {\n    layerCache[layerName] = createLayer();\n    map.add(layerCache[layerName]);\n\n    if (layerName === 'Solar Panels') {\n      layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n      map.add(layerCache['Polygon Outlines']);\n    }\n  }\n\n  return ui.Panel([checkbox], ui.Panel.Layout.flow('horizontal'));\n}\n\n// craete cache function\nvar chartCache = {\n  visualizeContent: null,\n  charts: []\n};\n\n// showPanel function\nfunction showPanel(panel, activeButton, inactiveButton) {\n  // hide all panels\n  visualizeContent.style().set('shown', false);\n  predictedContent.style().set('shown', false);\n  \n  // show the selected panel\n  if (panel === visualizeContent) {\n    visualizeContent.style().set('shown', true);\n    contentContainer.add(visualizeContent);\n  } else {\n    predictedContent.style().set('shown', true);\n    contentContainer.add(predictedContent);\n  }\n  \n  activeButton.style().set({fontWeight: 'bold'});\n  inactiveButton.style().set({fontWeight: 'bold'});\n}\n\n// Assemble UI and initialize\nmainPanel.add(buttonPanel);\nmainPanel.add(contentContainer);\n\n// Feature to click on solar farm polygons for more info:\nvar panel = null;\nvar highlightLayer = null;\n\n// Add map click handler\nmap.onClick(function(coords) {\n  var point = ee.Geometry.Point(coords.lon, coords.lat);\n  \n  // remove existing panel/highlight\n  if (panel !== null) {\n    map.remove(panel);\n    panel = null;\n  }\n  \n  if (highlightLayer !== null) {\n    map.remove(highlightLayer);\n    highlightLayer = null;\n  }\n  \n  // create panel\n  panel = ui.Panel({\n    style: {\n      position: 'top-right',\n      padding: '8px',\n      width: '320px',\n      backgroundColor: 'rgba(25, 25, 25, 0.8)'\n    }\n  });\n  \n  //define button to close the pop-up\n  var closeButton = ui.Button({\n    label: 'Close Panel',\n    style: {margin: '4px', backgroundColor: '00000000'}, //color: 'white'},\n    onClick: function() {\n      map.remove(panel);\n      panel = null;\n      if (highlightLayer !== null) {\n        map.remove(highlightLayer);\n        highlightLayer = null;\n      }\n    }\n  });\n\n  // show initial loading panel so the user knows something's happening\n  panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n       .add(ui.Label('Calculating...', {color: 'white', backgroundColor: '00000000'}));\n\n  map.add(panel);\n  \n  // extract properties from all_results\n  var featureWithArea = all_results\n  .filterBounds(point)\n  .map(function(f) {\n    return f.set('area_hectare', f.geometry().area().divide(1e6));\n  })\n  .first();\n\n  featureWithArea.evaluate(function(feature) { \n    //in case the user didn't select a panel\n    if (!feature) {\n      panel.clear();\n      panel.add(ui.Label('There are no solar farms at this location. Please select a new site.', \n      {fontSize: '16px', color: 'white', backgroundColor: '00000000'}))\n      .add(closeButton);\n      return;\n    }\n\n    // draw outline of selected feature\n    var geom = ee.Feature(feature).geometry();\n    highlightLayer = ui.Map.Layer(geom, {color: 'yellow', fillColor: '00000000', width: 3}, 'Selected Area');\n    map.add(highlightLayer);\n    \n    //extract properties from all_results\n    var props = feature.properties;\n  \n    // Update panel with actual info\n    panel.clear();\n    panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Installation date: ' + props.dateright, {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Average temperature change: ' + props.mean_LST_diff.toFixed(2) + '°C', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Area: ' + props.area_hectare.toFixed(2) + ' hectares', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Potential population affected: ' + props.total_buffer_pop, {color: 'white', backgroundColor: '00000000'}))\n         .add(closeButton);\n  });\n});\n\n\n\nThis section implements a prediction interface for analyzing the impact of solar farms on temperature and population. The main features include:\n\nDrawing Tools: users can draw a polygon on the map to select an area of interest.\nPrediction Processing: the model calculates temperature and population changes based on the selected area.\nResults Display: the interface shows the predicted temperature change, potential population affected, and a detailed summary of the results.\n\n// Initialize default view\nshowPanel(visualizeContent, buttons.visualize, buttons.predict);\n\n// Add to UI root\nui.root.add(ui.Panel([mainPanel, map], ui.Panel.Layout.flow('horizontal'), \n  {width: '100%', height: '100%'}));\n\n// clear the predictedContent\npredictedContent.clear();\n\n// add a description label\npredictedContent.add(ui.Label('To explore the effects of building a solar farm in a new site, please click the button below and draw a polygon on the map. Please make sure you draw the panel over a fish farm.', \n  {fontSize: '14px', margin: '0 0 10px 0'}));\n\n//Add button to draw the polygons\nvar drawButton = ui.Button({\n  label: 'Draw a new solar farm',\n  onClick: function() {\n    // clear the previous drawing\n    map.drawingTools().layers().reset();\n    map.drawingTools().setShape('polygon');\n    map.drawingTools().draw();\n    \n    // Disable the draw button and prevent further drawing\n    drawButton.setDisabled(true);\n    \n    // Start drawing and disable the drawing tools until drawing is complete\n    map.drawingTools().setShown(false);\n  },\n  style: {margin: '0 0 10px 0'}\n});\npredictedContent.add(drawButton);\n\n// add a results panel\nvar resultsPanel = ui.Panel({\n  style: {\n    margin: '10px 0',\n    padding: '5px',\n    border: '1px solid #ddd',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n    shown: false\n  }\n});\npredictedContent.add(resultsPanel);\n\n// add a loading label to the predictedContent\nvar loadingLabel = ui.Label('Please wait while the model runs...', {\n  fontStyle: 'italic',\n  fontSize: '15px',\n  //color: '#1a73e8',\n  margin: '10px 0',\n  shown: false\n});\npredictedContent.add(loadingLabel);\n\n// Create a small text label to appear under the results panel\nvar modelInfo = ui.Label('Please be aware that although the model is a useful tool, its predictions are unlikely to be perfectly accurate. The model explains 79% of variation in temperature change, with an average error of approximately 0.33°C.', {\n\n  shown:false\n});\npredictedContent.add(modelInfo);\n\n// Modify the map drawing completion event processing\nmap.drawingTools().onDraw(function(geometry) {\n  resultsPanel.clear();\n  loadingLabel.style().set('shown', true);  // show the loading label\n  modelInfo.style().set('shown', false); //ensure model explanation and results panel are hidden, even if they were shown before\n  resultsPanel.style().set('shown', false);\n  \n  //Only run if there is some intersection with fishfarms\n  var intersection = fishfarms.filterBounds(geometry).size().gt(0);\n  \n  intersection.evaluate(function(intersects) {\n    if (intersects) {\n\n    //Slightly changed version of the original analysis - does all calculations simultaneously to reduce waiting time\n      var computeScale = 30;\n      var feature = ee.Feature(geometry);\n      var pop = popBuffer(feature); //run pop function from above\n      var now = ee.Date(Date.now());\n      var polygonStart = now.advance(-3, 'year');\n      var polygonEnd = now;\n      var currentImage = ee.Image(getLST(geometry, polygonStart, polygonEnd)); //run LST calculation from above\n      var allComputations = ee.Dictionary({});\n\n      // perform the calculations separately and merge the results\n      var lstDict = currentImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var indicesDict = currentImage.select(['NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n        reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var elevationDict = elevation.reduceRegion({reducer: ee.Reducer.mean(),geometry: geometry,scale: computeScale, maxPixels: 1e13});\n      var slopeDict = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n\n      // Combine all the results\n      var combinedResults = ee.Dictionary(lstDict)\n        .combine(indicesDict)\n        .combine(elevationDict)\n        .combine(slopeDict)\n        .combine(pop.toDictionary(['total_buffer_pop', 'vulnerable_buffer_pop', 'child_buffer_pop', 'elderly_buffer_pop']));\n\n      combinedResults.evaluate(function(results) {\n        if (results.LST !== null) {\n          var currentLST = results.LST;\n          \n          //Create finished feature\n          var predictionFeature = ee.Feature(geometry, {\n            'NDVI': results.NDVI,\n            'NDBI': results.NDBI,\n            'B1': results.B1,\n            'B2': results.B2,\n            'B3': results.B3,\n            'B4': results.B4,\n            'B5': results.B5,\n            'B6': results.B6,\n            'B7': results.B7,\n            'B10': results.B10,\n            'B11': results.B11,\n            'elevation': results.elevation,\n            'slope': results.slope,\n            'area': geometry.area().divide(10000)});\n          \n          //Predict using model\n          var predicted = ee.FeatureCollection([predictionFeature]).classify(model);\n          predicted.first().get('classification').evaluate(function(futureTemp) {\n            var tempDiff = futureTemp - currentLST;\n            \n            //Hide loading label\n            loadingLabel.style().set('shown', false);\n            \n            //Print results\n            resultsPanel.style().set('shown', true);\n            resultsPanel.widgets().reset([ \n              ui.Label('Site Summary：', {fontWeight: 'bold', margin: '0 0 8px 0'}),\n              ui.Label('Current temperature：' + currentLST.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature with solar farm：' + futureTemp.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature change：' + tempDiff.toFixed(2) + '°C'),\n              ui.Label('Potential population affected：' + (results.total_buffer_pop || 0) + ' people'),\n              ui.Label('Potential vulnerable population affected：' + (results.vulnerable_buffer_pop || 0) + ' people'),\n              ui.Label('Populations are calculated within 730m of the polygon. Vulnerable population refers to estimated numbers of children (0-5) and elderly (60+) individuals living within this area.', {\n                  fontSize: '12px', fontStyle: 'italic'})\n            ]);\n            modelInfo.style().set('shown', true); \n            drawButton.setDisabled(false);\n            \n          });\n        } else {\n          loadingLabel.style().set('shown', false);\n          resultsPanel.style().set('shown', true);\n          resultsPanel.add(ui.Label('There is insufficient satellite imagery to calculate temperature for this location. Please select a different area.'));\n          drawButton.setDisabled(false);\n        }\n      });\n    } else {\n      loadingLabel.style().set('shown', false);\n      resultsPanel.style().set('shown', true);\n      resultsPanel.add(ui.Label('This polygon does not intersect with any fish farms. Please redraw in a different location.'));\n      drawButton.setDisabled(false);\n    }\n\n    //Stop and hide drawing tools once processing is finished\n    map.drawingTools().stop();\n    map.drawingTools().setShown(false);\n  });\n});\n\n\n\n\nFinal app\nGithHub repository\n\n\n\n\nBallinger, O. (1 January 2024) Refinery Identification [Module content], Building Spatial Applications with Big Data CASA0025, University College London.\nBarron-Gafford, G., Minor, R., Allen, N., Cronin, A., Brooks, A., Pavao-Zuckerman, M. and Macknick, J., 2016. The Photovoltaic Heat Island Effect: Larger solar power plants increase local temperatures. Scientific Reports, 6, p.35070. https://doi.org/10.1038/srep35070\nGuoqing, L., Hernandez, R.R., Blackburn, G.A., Davies, G., Hunt, M., Whyatt, J.D. and Armstrong, A., 2021. Ground-mounted photovoltaic solar parks promote land surface cool islands in arid ecosystems. Renewable and Sustainable Energy Transition, 1, p.100008.\nHsiao, Y.J., Chen, J.L. and Huang, C.T., 2021. What are the challenges and opportunities in implementing Taiwan’s aquavoltaics policy? A roadmap for achieving symbiosis between small-scale aquaculture and photovoltaics. Energy Policy, 153, p.112264.\nŠafanda, J., 1999. Ground surface temperature as a function of slope angle and slope orientation and its effect on the subsurface temperature field. Tectonophysics, 306(3-4), pp.367-375.\nUSGS, 2019. Landsat 8 (L8) Data Users Handbook. Obtained from https://d9-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/atoms/files/LSDS-1574_L8_Data_Users_Handbook-v5.0.pdf\nXu, Z., Li, Y., Qin, Y. and Bach, E., 2024. A global assessment of the effects of solar farms on albedo, vegetation, and land surface temperature using remote sensing. Solar Energy, 268, p.112198. https://doi.org/10.1016/j.solener.2023.112198"
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Although renewable energy is crucial to meeting Taiwan’s Net Zero goals, land availability represents a critical constraint (Hsiao et al., 2021). To address this, the Taiwanese government has implemented an aquavoltaics programme, integrating solar panels into fish farms to generate space-efficient energy. However, this initiative faces significant local opposition, with some authorities even banning construction due to concerns about socio-environmental impacts such as temperature increases, known as the photovoltaic heat island effect (PHVI). There is a clear need for an accessible, evidence-based participatory planning tool to resolve local conflicts, overcome planning roadblocks, and provide a foundation for informed programme expansion.\n\n\n\n\n\n\n\nThis application serves as a participatory planning tool to overcome conflicts between stakeholders with opposing perspectives on aquavoltaic expansion. It does this by openly exploring the PHVI impacts of past and prospective solar farms sites. Alongside expediting planning, helping mitigate local impacts, and supporting Taiwan’s Net Zero goals, additional benefits for each stakeholder are outlined below:\n\nNational government: communicating policy; mitigating unfounded concerns.\nLocal government: evidence-based assessment of past projects; informed future planning within jurisdictions.\nFish farmers: presenting a case for having solar panels installed on their sites.\nLocal residents: reducing concerns; empowering them to challenge decisions at higher governance levels.\n\n\n\n\n\nLandsat 8 Collection 1 Top of Atmosphere imagery at 30m resolution for temperature change assessments.\nSentinel-2 imagery at 10m resolution for fish farm identification.\nSolar panel polygons and construction dates from the Taiwanese Civil Service..\nPopulation estimates at 30m resolution from Meta’s Data for Good\nDigital elevation data at 30m resolution from the NASA Shuttle Radar Topography Mission.\n\n\n\n\nFirst, land surface temperature (LST) before and after solar panel installation is calculated using the method detailed by Xu et al., (2024), which averages satellite images for a period of three years before and after construction of the solar panel. A random forest model uses these changes, alongside optical and thermal imagery, slope, and elevation to predict temperature impacts at other sites. A second random forest identifies fish farms, ensuring users can only select prospective sites which could be included in the programme. Finally, predicted temperature change and local population estimates indicate the impact of developments on local communities.\n\n\n\nThe application provides a transparent, accessible tool to foster communication, improve collaboration, and bring clarity to a contentious issue. The interface is divided into two: the Explore tab provides a broad overview of PHVI impacts through summary statistics and charts, while the Predict tab enables site-specific predictions, allowing users to tailor insights to their local context. Users can click on solar farms to receive a summary at any point, either supplementing the overview or facilitating comparisons with prospective sites. A blue-to-red colour scheme intuitively communicates temperature changes, and clear chart titles and disclaimers ensure the analysis is understandable and transparent."
  },
  {
    "objectID": "index.html#the-application",
    "href": "index.html#the-application",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Replace the link below with the link to your application."
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "First, the data collection is filtered with a 25% cloud cover threshold and mean pixel values are calculated for a period of 3 years pre- and post-construction of the solar panel. LST is calculated using the following equation: LST = (BT / (1 + (0.00115 * (BT / 1.4388)) * Ln(ε))) found in the USGS handbook (2019). Other indices like NDVI and NDBI are also calculated in this step for the prediction model.\n// ------ LST Calculations ------\n\nfunction getLST(geom, start, end) {\n  var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n    .filterBounds(geom)\n    .filterDate(start, end)\n    .filter(ee.Filter.lt('CLOUD_COVER',25));\n\n  var lstCollection = collection.map(function(img) {\n    var ndvi = img.normalizedDifference(['B5', 'B4']).rename('NDVI');\n    var fv = ndvi.subtract(0).divide(1 - 0).rename('FV');\n    var em = fv.multiply(0.004).add(0.986).rename('EM');\n    var thermal = img.select('B10');\n    var lst = thermal.expression(\n      '(Tb / (1 + (0.00115 * (Tb / 1.438)) * log(Ep))) - 273.15',\n      {\n        'Tb': thermal,\n        'Ep': em\n      }\n    ).rename('LST');\n\n    //Extra variables for the random forest: optical bands, thermal bands, NDBI, and NDVI, FV, EM\n    var optical = img.select(['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']);\n    var thermalBands = img.select(['B10', 'B11']);\n    var ndbi = img.normalizedDifference(['B6', 'B5']).rename('NDBI');\n    return lst.addBands([ndvi, fv, em, ndbi]).addBands(optical).addBands(thermalBands).copyProperties(img, img.propertyNames());\n  });\n\n  var mean = ee.Image(lstCollection.mean());\n  var bands = mean.bandNames();\n  var hasLST = bands.contains('LST');\n  return ee.Algorithms.If(hasLST, mean.clip(geom), ee.Image().rename('LST').clip(geom));\n}\n\n// Calculate LST for all polygons\nfunction calculateLST(feature) {\n  var dateString = ee.String(feature.get('dateright'));\n  var parts = dateString.split('-');\n  var year = ee.Number.parse(parts.get(0));\n  var month = ee.Number.parse(parts.get(1));\n  var day = ee.Number.parse(parts.get(2));\n  var constructDate = ee.Date.fromYMD(year, month, day);\n\n  var preStart = constructDate.advance(-3, 'year');\n  var preEnd = constructDate;\n  var postStart = constructDate.advance(1, 'year');\n  var postEnd = constructDate.advance(4, 'year');\n\n  var geom = feature.geometry();\n  var preImage = ee.Image(getLST(geom, preStart, preEnd));\n  var postImage = ee.Image(getLST(geom, postStart, postEnd));\n  var diff = postImage.select('LST').subtract(preImage.select('LST')).rename('LST_Difference');\n\n  // Reducers for LST calculations\n  var meanPreLSTDict = preImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanPostLSTDict = postImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanDiffDict = diff.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n\n  // Reducers for other indices for RF\n  var preOpticalDict = preImage.select(['NDVI', 'FV', 'EM', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: geom,\n    scale: 30,\n    maxPixels: 1e13\n  });\n\n  var meanPreLST = ee.Algorithms.If(meanPreLSTDict.contains('LST'), meanPreLSTDict.get('LST'), null);\n  var meanPostLST = ee.Algorithms.If(meanPostLSTDict.contains('LST'), meanPostLSTDict.get('LST'), null);\n  var meanDiff = ee.Algorithms.If(meanDiffDict.contains('LST_Difference'), meanDiffDict.get('LST_Difference'), null);\n\n  return feature.set({\n    'mean_preLST': meanPreLST,\n    'mean_postLST': meanPostLST,\n    'mean_LST_diff': meanDiff\n  }).set(preOpticalDict).setGeometry(feature.geometry());\n}\nvar results = polygons.map(calculateLST);\nGiven local government and resident concerns about PHVI’s impact on surrounding communities, we define a function called popBuffer to sum estimated populations within 730 metres of solar farms: a distance typically affected by PHVI (Guoqing et al., 2021).\n//Load population from Data For Good\nvar HRSL_total = ee.ImageCollection('projects/sat-io/open-datasets/hrsl/hrslpop').filterBounds(taiwan).median();\n\n//Vulnerable population: sum of 0-5 and 60+\nvar HRSL_0_5 = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_children_under_five\").filterBounds(taiwan).median();\nvar HRSL_60plus = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_elderly_over_sixty\").filterBounds(taiwan).median();\nvar HRSL_vulnerable = HRSL_0_5.add(HRSL_60plus).rename('HRSL_vulnerable');\n\n//Calculate population within 730m buffer\nfunction popBuffer(panel) {\n  var geom = panel.geometry().buffer(730);\n  var totalPop = ee.Number(HRSL_total.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('b1')).round();\n  var vulnerablePop = ee.Number(HRSL_vulnerable.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('HRSL_vulnerable')).round();\n  return panel.set({'total_buffer_pop': totalPop, 'vulnerable_buffer_pop': vulnerablePop});\n}\nvar all_results = results.map(popBuffer);\nFinally, due to their impact on LST (Šafanda, 1999), we load slope and elevation data and reduce these to the means for each solar polygon. We also calculate polygon areas in hectares.\n//Add extra non-Landsat features: elevation, topography, and polygon area\nvar srtm = ee.Image('USGS/SRTMGL1_003').clip(taiwan);\nvar elevation = srtm.select('elevation');\nvar slope = ee.Terrain.slope(srtm);\n\nvar allFeatures = validFeatures.map(function(feature) {\n  var geom = feature.geometry();\n  var meanElevation = elevation.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('elevation');\n  var meanSlope = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('slope');\n  var area = geom.area().divide(10000); //converting to ha as metres were overwhelming the model\n  return feature.set({\n    'elevation': meanElevation,\n    'slope': meanSlope,\n    'area': area});\n});\n\n\n\nAfter filtering all polygons to ensure they contain the necessary data, variables were extracted to conduct principal component analysis in Python to reduce dimensionality and prevent multicollinearity. The resultant random forest model is trained on 70% of the polygons, and has an R^2 of 0.79. It has a low RMSE and MAE relative to average temperature change, making it suitable for predicting changes in new sites.\n//Extract training data\nvar bands = test.select(['mean_preLST', 'mean_postLST', 'mean_LST_diff', 'NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area'])\n  .randomColumn();\n\n//Define test-train split\nvar split=0.7\nvar training_sample = bands.filter(ee.Filter.lt('random', split));\nvar validation_sample = bands.filter(ee.Filter.gte('random', split));\n\nprint('Sample training feature:', training_sample.first())\n\n//Set up RF\nvar model = ee.Classifier.smileRandomForest(100)\n  .setOutputMode('REGRESSION')\n  .train({\n    features: training_sample,\n    classProperty: 'mean_postLST',\n    //removed mean_preLST, EM, FV due to multicollinearity\n    inputProperties: ['NDVI', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area']});\nIf users are to select potential aquavoltaic installation sites, it is imperative that these are actually fish farms. We used a random forest model to identify existing fish farms based on Sentinel-2 imagery, drawing from Ballinger’s (2024) oil refinery identification. The model is trained and tested on manually drawn land identification polygons. The resulting prediction data was then manually cleaned in QGIS. In the prediction tab of the final application, the user’s polygon selection is required to intersect with a fish farm. While the model is not perfectly accurate, it sufficiently limits user input to areas with fish farms.\n\n// pre-process imagery\nvar start='2021-04-14';\nvar end='2025-04-14';\nvar bands = ['B2', 'B3', 'B4','B5','B6','B7','B8', 'B8A','B11','B12'];\n\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n                \nvar s_rgb = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nvar sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n  .filterBounds(AOI)\n  .filterDate(start, end)\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n  .select('VV')\n  .mean();\n\nvar ndvi=sentinel.normalizedDifference(['B8','B4']).select(['nd'],['ndvi']);\nvar ndwi=sentinel.normalizedDifference(['B3','B8']).select(['nd'],['ndwi'])\nvar newBands = ee.Image([ndwi,ndvi,sentinel1.rename('S1_VV')]);\nvar image=sentinel.addBands(newBands).clip(AOI);\n\n// add AOI and satellite imagery to map\nMap.addLayer(image.clip(AOI), s_rgb, 'Sentinel');\nMap.addLayer(AOI,null,\"AOI\",false);\n\n// select random points from each land type for training/validation\nvar fishfarm_points=ee.FeatureCollection.randomPoints(fishfarms, 3000).map(function(i){\n  return i.set({'class': 0})});\n  \nvar urban_points=ee.FeatureCollection.randomPoints(urban, 1000).map(function(i){\n  return i.set({'class': 1})});\n\n  \nvar river_points=ee.FeatureCollection.randomPoints(rivers, 2000).map(function(i){\n  return i.set({'class': 2})});  \n\nvar sample=ee.FeatureCollection([urban_points,\n                                  fishfarm_points,\n                                  river_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();\n\n// take samples from image for training and validation   \nvar split=0.7\nvar training_sample = sample.filter(ee.Filter.lt('random', split));\nvar validation_sample = sample.filter(ee.Filter.gte('random', split));\n\nvar training = image.sampleRegions({\n  collection: training_sample,\n  properties: ['class'],\n  scale: 10,\n});\n\nvar validation = image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// create model and run to create predictions\nvar model = ee.Classifier.smileRandomForest(400)\n.train(training, 'class');\n\nvar prediction = image.classify(model);\n\nvar fishfarm_prediction=prediction.updateMask(prediction.eq(0));\n\nMap.addLayer(fishfarm_prediction,{palette:'red'},'Predicted Fish Farms');\n\n// Assess accuracy of model\nvar validated = validation.classify(model);\n\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\nprint('Confusion Matrix ', testAccuracy);\nprint('Validation overall accuracy: ', testAccuracy.accuracy())\n\n\n\n\n\n\nThis code builds an interactive user interface (UI) in Google Earth Engine. It structures the app into two main parts: a Main Panel and a Map. The Main Panel includes two navigation buttons (to switch between exploring existing solar farms or predicting impacts for new sites), and a content container that updates to show either statistics, charts, and layer controls, or drawing tools for prediction.\n/*\nRoot\n├── Main Panel\n│   ├── Title\n│   ├── Button Panel\n│   │   ├── Visualize Button\n│   │   └── Predict Button\n│   └── Content Container\n│       ├── Visualize Content\n│       │   ├── Statistics Cards\n│       │   ├── Charts\n│       │   └── Layer Controls\n│       └── Predict Content\n│           ├── Drawing Tools\n│           └── Results Panel\n└── Map\n    ├── Base Layer\n    ├── Solar Panels Layer\n    ├── Fish Farms Layer\n    └── Population Layer\n*/\n\n// Clear UI and define core functions\nui.root.clear();\n\n// Initialize main UI components\nvar mainPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {width: '500px', padding: '10px'}\n});\n\nvar map = ui.Map();\nmap.setOptions('SATELLITE');\nmap.setCenter(120.10159388310306, 23.119258878572882, 13.5)\n\n//Add a legend\nvar legend = ui.Panel({style: {position: 'bottom-left', padding: '8px 15px'}});\nvar legendTitle = ui.Label({value: 'Temperature Difference (°C)', style: {fontWeight: 'bold', fontSize: '14px', margin: '0 0 4px 0'}});\nlegend.add(legendTitle);\n//Set visualisation parameters - same as polygons\nvar palette = palettes.colorbrewer.RdBu[9].reverse();\nvar min = -6;\nvar max = 6;\n//Set up colour bar\nvar colorBar = ui.Thumbnail({image: ee.Image.pixelLonLat().select(0).multiply((max - min) / 100.0).add(min)\n           .visualize({min: min, max: max, palette: palette}),\n  params: {bbox: [0, 0, 100, 10], dimensions: '100x10'},\n  style: {stretch: 'horizontal', margin: '0px 8px', maxHeight: '24px'}\n});\nlegend.add(colorBar);\n//Add labels\nvar legendLabels = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {margin: '1px 0 0 0'}\n});\nlegendLabels.add(ui.Label(min.toString(), {fontSize: '12px'}));\nlegendLabels.add(ui.Label(' ', {stretch: 'horizontal'})); // Spacer\nlegendLabels.add(ui.Label(max.toString(), {fontSize: '12px'}));\nlegend.add(legendLabels);\nmap.add(legend);\n\n// Create UI panels and buttons\nmainPanel.add(ui.Panel({\n  widgets: [ui.Label('Tainan Solar Farm Heat Impact App', \n    {fontWeight: 'bold', fontSize: '22px', margin: '0 0 10px 0', padding: '6px'})],\n  style: {padding: '0'}\n}));\n\n// Content panels\nvar visualizeContent = ui.Panel({style: {border: '1px solid #999', padding: '8px'}});\nvar predictedContent = ui.Panel({\n  widgets: [ui.Label('Still working', {fontSize: '16px', padding: '20px'})],\n  style: {border: '1px solid #999', padding: '8px'}\n});\n\n// Navigation buttons\nvar buttons = {\n  visualize: ui.Button({\n    label: 'Explore Existing Solar Farms',\n    onClick: function() {\n      showPanel(visualizeContent, buttons.visualize, buttons.predict);\n    },\n    style: {padding: '4px', fontWeight: 'bold', \n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  }),\n  predict: ui.Button({\n    label: 'Predict Change in a New Site',\n    onClick: function() {\n      showPanel(predictedContent, buttons.predict, buttons.visualize);\n    },\n    style: {padding: '4px', fontWeight: 'bold',\n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  })\n};\n// Button panel and container\nvar buttonPanel = ui.Panel([buttons.visualize, buttons.predict], \n  ui.Panel.Layout.flow('horizontal'), {margin: '0 0 20px 0'});\nvar contentContainer = ui.Panel();\n\n\n\nThis code builds a visualization interface to analyze solar farm impacts. It features three toggleable layers (solar panels, fish ponds, population estimates) managed by layerConfigs and createLayerControl. It displays solar farm counts, installation dates, statistic cards, and three charts. Users can interactively click farms for details and customize visible data through the control panel.\n//Set solar panel visualisation parameters\nvar solarStyle = {min: -6, max: 6, palette: palettes.colorbrewer.RdBu[9]}; //for some reason we don't reverse it bc we've already reversed the legend!\n\n//Reduce to image for faster loading\nvar solarImage = results.reduceToImage({properties: ['mean_LST_diff'], reducer: ee.Reducer.mean()}).rename('mean_LST_diff');\n\n//Add outlines so users can later select polygons\nvar outlinedPolygons = results.style({color: 'black', fillColor: '00000000', width: 0.5});\nMap.addLayer(outlinedPolygons, {}, 'Polygon Outlines');\n\n// define layerConfigs\nvar layerConfigs = {\n  'Solar Panels': {\n    layer: solarImage,\n    defaultVisible: true,\n    visParams: solarStyle,\n    type: 'raster'\n  },\n  \n  'Fish Farms': {\n    layer: fishfarms,\n    defaultVisible: false,\n    visParams: {\n      color: 'blue',\n      fillColor: '#87CEEB88',\n      width: 0\n    },\n    type: 'vector'\n  },\n  'Population Estimates': {\n    layer: HRSL_total, //.select('b1'),\n    defaultVisible: false,\n    visParams: {\n      min: 0,\n      max: 16,\n      palette: ['#A902A9'], //just a single colour, we don't want to complicate visualisation by having different pop colours too\n      opacity: 0.5},\n    type: 'raster'}\n};\n\n// define layer cache\nvar layerCache = {};\n\n// define layer order for UI display\nvar uiLayerOrder = [\n  'Solar Panels',\n  'Fish Farms',\n  'Population Estimates'\n];\n\n// define layer order for map display\nvar layerOrder = {\n  'Fish Farms': 1,\n  'Population Estimates': 2,\n  'Solar Panels': 3\n};\n\n//Add general instructions first\nvisualizeContent.add(ui.Label('Welcome!', {fontWeight:'bold', fontSize:'18px'}));\nvisualizeContent.add(ui.Label(\n  'This app uses satellite imagery to explore how solar farms influence local temperatures and communities.\\n\\n' +\n  'Use the map and this Explore tab to get a broad understanding of solar farm impacts. Click on a solar farm on the map to get more information about it. Finally, visit the Prediction tab to assess the potential effects of building a new solar farm in a location of your choice.',\n  {whiteSpace: 'pre-line'}\n));\n\n// add layer control to visualizeContent\nvisualizeContent.add(ui.Label('Select Data to Display:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\nuiLayerOrder.forEach(function(layerName) {\n  visualizeContent.add(createLayerControl(layerName));\n});\n\n// add Summary Statistics panel\nvisualizeContent.add(ui.Label('Overview:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n//Add total polygon numbers\nvar totalPanelsLabel = ui.Label('Loading total polygons count...', {\n  fontSize: '14px',\n  color: 'gray'});\nvisualizeContent.add(totalPanelsLabel);\n\ntotalPanels.evaluate(function(count) { //replace when calculated\n  visualizeContent.remove(totalPanelsLabel);\n  var boldLabel = ui.Label(String(count), {\n    fontSize: '15px', fontWeight: 'bold', color: 'black', padding: '0', margin: '0 4px 0 0'});\n  var regularLabel = ui.Label(' solar farms installed since March 2019.', {\n    fontSize: '15px', color: 'black', padding: '0', margin: '0'});\n  //Use a panel to make sure they're added next to each other\n  var labelPanel = ui.Panel({\n    widgets: [boldLabel, regularLabel],\n    layout: ui.Panel.Layout.flow('horizontal'),\n    style: {padding: '0', margin: '4px'}});\n  visualizeContent.widgets().insert(7, labelPanel); //make sure it's added in same position as before - ChatGPT helped\n});\n\n//Add summary statistics\nvar statCardsPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '10px 0'}\n});\n\n//Add a loading screen before the stats are calculated\nvar loadingCard = ui.Label('Loading maximum, minimum, and average temperature change...', {\n  fontSize: '14px',\n  color: 'gray',\n});\nstatCardsPanel.add(loadingCard);\n\nfunction createStatCard(label, value, color,textColor) {\n  return ui.Panel([\n    ui.Label(label, {\n      fontWeight: 'bold',\n      fontSize: '14px',\n      color: textColor,\n      backgroundColor: color\n    }),\n    ui.Label(value, {\n      fontSize: '18px',\n      color: textColor,\n      backgroundColor: color\n    })\n  ], ui.Panel.Layout.flow('vertical'), {\n    padding: '10px',\n    backgroundColor: color,\n    borderRadius: '8px',\n    margin: '4px',\n    width: '30%'\n  });\n}\n\n//Add Stat Cards in the order: min, max, average\nminTempChange.evaluate(function(min) {\n  statCardsPanel.clear(); //remove the loading bit\n  statCardsPanel.add(createStatCard('Min Temp Change', min.toFixed(2) + ' °C', '#2166ac','white'));\n  \n  averageTempChange.evaluate(function(avg) {\n    statCardsPanel.add(createStatCard('Avg Temp Change', avg.toFixed(2) + ' °C', '#f7f7f7','black'));\n\n    maxTempChange.evaluate(function(max) {\n      statCardsPanel.add(createStatCard('Max Temp Change', max.toFixed(2) + ' °C', '#b2182b','white'));\n    });\n  });\n});\nvisualizeContent.add(statCardsPanel);\n\n// add chart label and container\nvisualizeContent.add(ui.Label('Deeper Trends:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n// Create charts directly\nvar tempDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'mean_LST_diff',\n  minBucketWidth: 0.1\n}).setOptions({\n  title: 'What is the distribution of temperature change?',\n  hAxis: {title: 'Temperature Change (°C)'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#FE8789']\n});\n\nvar popDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'total_buffer_pop',\n  minBucketWidth: 50\n}).setOptions({\n  title: 'How many people typically live near a solar farm?',\n  hAxis: {title: 'Total Population Within 730m'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#A902A9']\n});\n\nvar nicerName = allFeatures.map(function(feature) { //improve appearance\n  return feature.set('Temperature Change (°C)', feature.get('mean_LST_diff'));\n});\n\nvar tempVsAreaChart = ui.Chart.feature.byFeature(\n  nicerName.filter(ee.Filter.notNull(['area', 'Temperature Change (°C)'])),\n  'area',\n  'Temperature Change (°C)'\n).setChartType('ScatterChart')\n .setOptions({\n   title: 'Is there a relationship between solar farm area and temperature?',\n   hAxis: {\n     title: 'Logged Area (hectares)',\n     scaleType: 'log',\n     format: 'short'\n   },\n   vAxis: {\n     title: 'Temperature Change (°C)',\n     viewWindow: {\n       min: -1,\n       max: 5\n     }\n   },\n   pointSize: 1,\n   colors: ['#ff8800'],\n   legend: {position: 'none'},\n   chartArea: {width: '85%', height: '80%'},\n   series: {0: {labelInLegend: 'Temp Change (°C)'}}\n });\n\n// Create a container for all charts\nvar chartsContainer = ui.Panel({\n  style: {margin: '10px 0'}\n});\n\n// Add charts to the container\nvisualizeContent.add(tempDistChart);\nvisualizeContent.add(popDistChart);\nvisualizeContent.add(tempVsAreaChart);\n\n\n//add disclaimer\nvisualizeContent.add(ui.Label(\n  'Please note that charts and summary statistics are based on a random sample of all solar farms. Although they closely reflect overall trends, exact values may vary slightly.',\n  {fontSize: '13px', fontStyle: 'italic'}));\n\n// then define createLayerControl function\nfunction createLayerControl(layerName) {\n  var config = layerConfigs[layerName];\n  \n  function createLayer() {\n    if (config.type === 'vector') {\n      return ui.Map.Layer({\n        eeObject: config.layer.style(config.visParams),\n        name: layerName,\n        shown: config.defaultVisible\n      });\n    }\n    return ui.Map.Layer({\n      eeObject: config.layer,\n      visParams: config.visParams,\n      name: layerName,\n      shown: config.defaultVisible\n    });\n  }\n\n  var checkbox = ui.Checkbox({\n    label: layerName,\n    value: config.defaultVisible,\n    onChange: function(checked) {\n      if (!layerCache[layerName]) {\n        layerCache[layerName] = createLayer();\n      }\n      \n      layerCache[layerName].setShown(checked);\n\n      // Add logic to link solar panel outlines (i.e. features) to the coloured panels (images) - ChatGPT helped here\n      if (layerName === 'Solar Panels') {\n        if (checked) {\n          layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n        } else {\n          layerCache['Polygon Outlines'] = null;\n        }\n      }\n\n      var visibleLayers = [];\n      // Sort layers by layerOrder\n      var sortedLayers = Object.keys(layerConfigs).sort(function(a, b) {\n        return layerOrder[a] - layerOrder[b];\n      });\n      \n      sortedLayers.forEach(function(name) {\n        if (layerCache[name] && layerCache[name].getShown()) {\n          visibleLayers.push(layerCache[name]);\n        }\n\n        //Again, ensure solar panel outlines are being shown if solar panels are\n        if (name === 'Solar Panels' && layerCache['Polygon Outlines']) {\n          visibleLayers.push(layerCache['Polygon Outlines']);\n        }\n      });\n\n      map.layers().reset(visibleLayers);\n    }\n  });\n\n  //Default load solar panel outlines, even though we don't want this to be shown in the UI\n  if (config.defaultVisible) {\n    layerCache[layerName] = createLayer();\n    map.add(layerCache[layerName]);\n\n    if (layerName === 'Solar Panels') {\n      layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n      map.add(layerCache['Polygon Outlines']);\n    }\n  }\n\n  return ui.Panel([checkbox], ui.Panel.Layout.flow('horizontal'));\n}\n\n// craete cache function\nvar chartCache = {\n  visualizeContent: null,\n  charts: []\n};\n\n// showPanel function\nfunction showPanel(panel, activeButton, inactiveButton) {\n  // hide all panels\n  visualizeContent.style().set('shown', false);\n  predictedContent.style().set('shown', false);\n  \n  // show the selected panel\n  if (panel === visualizeContent) {\n    visualizeContent.style().set('shown', true);\n    contentContainer.add(visualizeContent);\n  } else {\n    predictedContent.style().set('shown', true);\n    contentContainer.add(predictedContent);\n  }\n  \n  activeButton.style().set({fontWeight: 'bold'});\n  inactiveButton.style().set({fontWeight: 'bold'});\n}\n\n// Assemble UI and initialize\nmainPanel.add(buttonPanel);\nmainPanel.add(contentContainer);\n\n// Feature to click on solar farm polygons for more info:\nvar panel = null;\nvar highlightLayer = null;\n\n// Add map click handler\nmap.onClick(function(coords) {\n  var point = ee.Geometry.Point(coords.lon, coords.lat);\n  \n  // remove existing panel/highlight\n  if (panel !== null) {\n    map.remove(panel);\n    panel = null;\n  }\n  \n  if (highlightLayer !== null) {\n    map.remove(highlightLayer);\n    highlightLayer = null;\n  }\n  \n  // create panel\n  panel = ui.Panel({\n    style: {\n      position: 'top-right',\n      padding: '8px',\n      width: '320px',\n      backgroundColor: 'rgba(25, 25, 25, 0.8)'\n    }\n  });\n  \n  //define button to close the pop-up\n  var closeButton = ui.Button({\n    label: 'Close Panel',\n    style: {margin: '4px', backgroundColor: '00000000'}, //color: 'white'},\n    onClick: function() {\n      map.remove(panel);\n      panel = null;\n      if (highlightLayer !== null) {\n        map.remove(highlightLayer);\n        highlightLayer = null;\n      }\n    }\n  });\n\n  // show initial loading panel so the user knows something's happening\n  panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n       .add(ui.Label('Calculating...', {color: 'white', backgroundColor: '00000000'}));\n\n  map.add(panel);\n  \n  // extract properties from all_results\n  var featureWithArea = all_results\n  .filterBounds(point)\n  .map(function(f) {\n    return f.set('area_hectare', f.geometry().area().divide(1e6));\n  })\n  .first();\n\n  featureWithArea.evaluate(function(feature) { \n    //in case the user didn't select a panel\n    if (!feature) {\n      panel.clear();\n      panel.add(ui.Label('There are no solar farms at this location. Please select a new site.', \n      {fontSize: '16px', color: 'white', backgroundColor: '00000000'}))\n      .add(closeButton);\n      return;\n    }\n\n    // draw outline of selected feature\n    var geom = ee.Feature(feature).geometry();\n    highlightLayer = ui.Map.Layer(geom, {color: 'yellow', fillColor: '00000000', width: 3}, 'Selected Area');\n    map.add(highlightLayer);\n    \n    //extract properties from all_results\n    var props = feature.properties;\n  \n    // Update panel with actual info\n    panel.clear();\n    panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Installation date: ' + props.dateright, {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Average temperature change: ' + props.mean_LST_diff.toFixed(2) + '°C', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Area: ' + props.area_hectare.toFixed(2) + ' hectares', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Potential population affected: ' + props.total_buffer_pop, {color: 'white', backgroundColor: '00000000'}))\n         .add(closeButton);\n  });\n});\n\n\n\nThis section implements a prediction interface for analyzing the impact of solar farms on temperature and population. The main features include:\n\nDrawing Tools: users can draw a polygon on the map to select an area of interest.\nPrediction Processing: the model calculates temperature and population changes based on the selected area.\nResults Display: the interface shows the predicted temperature change, potential population affected, and a detailed summary of the results.\n\n// Initialize default view\nshowPanel(visualizeContent, buttons.visualize, buttons.predict);\n\n// Add to UI root\nui.root.add(ui.Panel([mainPanel, map], ui.Panel.Layout.flow('horizontal'), \n  {width: '100%', height: '100%'}));\n\n// clear the predictedContent\npredictedContent.clear();\n\n// add a description label\npredictedContent.add(ui.Label('To explore the effects of building a solar farm in a new site, please click the button below and draw a polygon on the map. Please make sure you draw the panel over a fish farm.', \n  {fontSize: '14px', margin: '0 0 10px 0'}));\n\n//Add button to draw the polygons\nvar drawButton = ui.Button({\n  label: 'Draw a new solar farm',\n  onClick: function() {\n    // clear the previous drawing\n    map.drawingTools().layers().reset();\n    map.drawingTools().setShape('polygon');\n    map.drawingTools().draw();\n    \n    // Disable the draw button and prevent further drawing\n    drawButton.setDisabled(true);\n    \n    // Start drawing and disable the drawing tools until drawing is complete\n    map.drawingTools().setShown(false);\n  },\n  style: {margin: '0 0 10px 0'}\n});\npredictedContent.add(drawButton);\n\n// add a results panel\nvar resultsPanel = ui.Panel({\n  style: {\n    margin: '10px 0',\n    padding: '5px',\n    border: '1px solid #ddd',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n    shown: false\n  }\n});\npredictedContent.add(resultsPanel);\n\n// add a loading label to the predictedContent\nvar loadingLabel = ui.Label('Please wait while the model runs...', {\n  fontStyle: 'italic',\n  fontSize: '15px',\n  //color: '#1a73e8',\n  margin: '10px 0',\n  shown: false\n});\npredictedContent.add(loadingLabel);\n\n// Create a small text label to appear under the results panel\nvar modelInfo = ui.Label('Please be aware that although the model is a useful tool, its predictions are unlikely to be perfectly accurate. The model explains 79% of variation in temperature change, with an average error of approximately 0.33°C.', {\n\n  shown:false\n});\npredictedContent.add(modelInfo);\n\n// Modify the map drawing completion event processing\nmap.drawingTools().onDraw(function(geometry) {\n  resultsPanel.clear();\n  loadingLabel.style().set('shown', true);  // show the loading label\n  modelInfo.style().set('shown', false); //ensure model explanation and results panel are hidden, even if they were shown before\n  resultsPanel.style().set('shown', false);\n  \n  //Only run if there is some intersection with fishfarms\n  var intersection = fishfarms.filterBounds(geometry).size().gt(0);\n  \n  intersection.evaluate(function(intersects) {\n    if (intersects) {\n\n    //Slightly changed version of the original analysis - does all calculations simultaneously to reduce waiting time\n      var computeScale = 30;\n      var feature = ee.Feature(geometry);\n      var pop = popBuffer(feature); //run pop function from above\n      var now = ee.Date(Date.now());\n      var polygonStart = now.advance(-3, 'year');\n      var polygonEnd = now;\n      var currentImage = ee.Image(getLST(geometry, polygonStart, polygonEnd)); //run LST calculation from above\n      var allComputations = ee.Dictionary({});\n\n      // perform the calculations separately and merge the results\n      var lstDict = currentImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var indicesDict = currentImage.select(['NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n        reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var elevationDict = elevation.reduceRegion({reducer: ee.Reducer.mean(),geometry: geometry,scale: computeScale, maxPixels: 1e13});\n      var slopeDict = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n\n      // Combine all the results\n      var combinedResults = ee.Dictionary(lstDict)\n        .combine(indicesDict)\n        .combine(elevationDict)\n        .combine(slopeDict)\n        .combine(pop.toDictionary(['total_buffer_pop', 'vulnerable_buffer_pop', 'child_buffer_pop', 'elderly_buffer_pop']));\n\n      combinedResults.evaluate(function(results) {\n        if (results.LST !== null) {\n          var currentLST = results.LST;\n          \n          //Create finished feature\n          var predictionFeature = ee.Feature(geometry, {\n            'NDVI': results.NDVI,\n            'NDBI': results.NDBI,\n            'B1': results.B1,\n            'B2': results.B2,\n            'B3': results.B3,\n            'B4': results.B4,\n            'B5': results.B5,\n            'B6': results.B6,\n            'B7': results.B7,\n            'B10': results.B10,\n            'B11': results.B11,\n            'elevation': results.elevation,\n            'slope': results.slope,\n            'area': geometry.area().divide(10000)});\n          \n          //Predict using model\n          var predicted = ee.FeatureCollection([predictionFeature]).classify(model);\n          predicted.first().get('classification').evaluate(function(futureTemp) {\n            var tempDiff = futureTemp - currentLST;\n            \n            //Hide loading label\n            loadingLabel.style().set('shown', false);\n            \n            //Print results\n            resultsPanel.style().set('shown', true);\n            resultsPanel.widgets().reset([ \n              ui.Label('Site Summary：', {fontWeight: 'bold', margin: '0 0 8px 0'}),\n              ui.Label('Current temperature：' + currentLST.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature with solar farm：' + futureTemp.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature change：' + tempDiff.toFixed(2) + '°C'),\n              ui.Label('Potential population affected：' + (results.total_buffer_pop || 0) + ' people'),\n              ui.Label('Potential vulnerable population affected：' + (results.vulnerable_buffer_pop || 0) + ' people'),\n              ui.Label('Populations are calculated within 730m of the polygon. Vulnerable population refers to estimated numbers of children (0-5) and elderly (60+) individuals living within this area.', {\n                  fontSize: '12px', fontStyle: 'italic'})\n            ]);\n            modelInfo.style().set('shown', true); \n            drawButton.setDisabled(false);\n            \n          });\n        } else {\n          loadingLabel.style().set('shown', false);\n          resultsPanel.style().set('shown', true);\n          resultsPanel.add(ui.Label('There is insufficient satellite imagery to calculate temperature for this location. Please select a different area.'));\n          drawButton.setDisabled(false);\n        }\n      });\n    } else {\n      loadingLabel.style().set('shown', false);\n      resultsPanel.style().set('shown', true);\n      resultsPanel.add(ui.Label('This polygon does not intersect with any fish farms. Please redraw in a different location.'));\n      drawButton.setDisabled(false);\n    }\n\n    //Stop and hide drawing tools once processing is finished\n    map.drawingTools().stop();\n    map.drawingTools().setShown(false);\n  });\n});\n\n\n\n\nFinal app\nGithHub repository"
  },
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "",
    "section": "",
    "text": "Use this repository to host a website for your CASA0025 final project by following these stpes:\n\nclone this repository\ninstall quarto\nedit the ‘index.qmd’ file with the contents of your project\nusing terminal, navigate to the project directory and run “quarto render”\npush the changes to your github repository\non github, navigate to Settings&gt;Pages&gt;Build and Deployment. Make sure that under “Source” it says “deploy from branch”. Under “Branch”, select “Main” in the first dropdown and “Docs” under the second drop down. Then press “Save”\n\nYour website should now be available under https://{your_username}.github.io/{your_repo_name}"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Ballinger, O. (1 January 2024) Refinery Identification [Module content], Building Spatial Applications with Big Data CASA0025, University College London.\nBarron-Gafford, G., Minor, R., Allen, N., Cronin, A., Brooks, A., Pavao-Zuckerman, M. and Macknick, J., 2016. The Photovoltaic Heat Island Effect: Larger solar power plants increase local temperatures. Scientific Reports, 6, p.35070. https://doi.org/10.1038/srep35070\nGuoqing, L., Hernandez, R.R., Blackburn, G.A., Davies, G., Hunt, M., Whyatt, J.D. and Armstrong, A., 2021. Ground-mounted photovoltaic solar parks promote land surface cool islands in arid ecosystems. Renewable and Sustainable Energy Transition, 1, p.100008.\nHsiao, Y.J., Chen, J.L. and Huang, C.T., 2021. What are the challenges and opportunities in implementing Taiwan’s aquavoltaics policy? A roadmap for achieving symbiosis between small-scale aquaculture and photovoltaics. Energy Policy, 153, p.112264.\nŠafanda, J., 1999. Ground surface temperature as a function of slope angle and slope orientation and its effect on the subsurface temperature field. Tectonophysics, 306(3-4), pp.367-375.\nUSGS, 2019. Landsat 8 (L8) Data Users Handbook. Obtained from https://d9-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/atoms/files/LSDS-1574_L8_Data_Users_Handbook-v5.0.pdf\nXu, Z., Li, Y., Qin, Y. and Bach, E., 2024. A global assessment of the effects of solar farms on albedo, vegetation, and land surface temperature using remote sensing. Solar Energy, 268, p.112198. https://doi.org/10.1016/j.solener.2023.112198"
  },
  {
    "objectID": "solar_panel.html",
    "href": "solar_panel.html",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Although renewable energy is crucial to meeting Taiwan’s Net Zero goals, land availability represents a critical constraint (Hsiao et al., 2021). To address this, the Taiwanese government has implemented an aquavoltaics programme, integrating solar panels into fish farms to generate space-efficient energy. However, this initiative faces significant local opposition, with some authorities even banning construction due to concerns about socio-environmental impacts such as temperature increases, known as the photovoltaic heat island effect (PHVI). There is a clear need for an accessible, evidence-based participatory planning tool to resolve local conflicts, overcome planning roadblocks, and provide a foundation for informed programme expansion.\n\n\n\n\n\n\n\nThis application serves as a participatory planning tool to overcome conflicts between stakeholders with opposing perspectives on aquavoltaic expansion. It does this by openly exploring the PHVI impacts of past and prospective solar sites. Alongside expediting planning, helping mitigate local impacts, and supporting Taiwan’s Net Zero goals, additional benefits for each stakeholder are outlined below:\n\nNational government: communicating policy; mitigating unfounded concerns.\nLocal government: evidence-based assessment of past projects; informed future planning within jurisdictions.\nFish farmers: presenting a case for having solar panels installed on their sites.\nLocal residents: reducing concerns; empowering them to challenge decisions at higher governance levels.\n\n\n\n\n\nLandsat 8 Collection 1 Top of Atmosphere imagery at 30m resolution for temperature change assessments.\nSentinel-2 imagery at 10m resolution for fish farm identification.\nSolar panel polygons and construction dates from the Taiwanese Civil Service..\nPopulation estimates at 30m resolution from Meta’s Data for Good\nDigital elevation data at 30m resolution from the NASA Shuttle Radar Topography Mission.\n\n\n\n\nFirst, land surface temperature (LST) before and after solar panel installation is calculated using the method detailed by Xu et al., (2024), which averages satellite images for a period of three years before and after construction of the solar panel. A random forest model uses these changes, alongside optical and thermal imagery, slope, and elevation to predict temperature impacts at other sites. A second random forest identifies fish farms, ensuring users can only select prospective sites which could be included in the programme. Finally, predicted temperature change and local population estimates indicate the impact of developments on local communities.\n\n\n\nThe application provides a transparent, accessible tool to foster communication, improve collaboration, and bring clarity to a contentious issue. The interface is divided into two: the Explore tab provides a broad overview of PHVI impacts through summary statistics and charts, while the Predict tab enables site-specific predictions, allowing users to tailor insights to their local context. Users can click on solar farms to receive a summary at any point, either supplementing the overview or facilitating comparisons with prospective sites. A blue-to-red colour scheme intuitively communicates temperature changes, and clear chart titles and disclaimers ensure the analysis is understandable and transparent.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst, the data collection is filtered with a 25% cloud cover threshold and mean pixel values are calculated for a period of 3 years pre- and post-construction of the solar panel. LST is calculated using the following equation: LST = (BT / (1 + (0.00115 * (BT / 1.4388)) * Ln(ε))) found in the USGS handbook (2019). Other indices like NDVI and NDBI are also calculated in this step for the prediction model.\n// ------ LST Calculations ------\n\nfunction getLST(geom, start, end) {\n  var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n    .filterBounds(geom)\n    .filterDate(start, end)\n    .filter(ee.Filter.lt('CLOUD_COVER',25));\n\n  var lstCollection = collection.map(function(img) {\n    var ndvi = img.normalizedDifference(['B5', 'B4']).rename('NDVI');\n    var fv = ndvi.subtract(0).divide(1 - 0).rename('FV');\n    var em = fv.multiply(0.004).add(0.986).rename('EM');\n    var thermal = img.select('B10');\n    var lst = thermal.expression(\n      '(Tb / (1 + (0.00115 * (Tb / 1.438)) * log(Ep))) - 273.15',\n      {\n        'Tb': thermal,\n        'Ep': em\n      }\n    ).rename('LST');\n\n    //Extra variables for the random forest: optical bands, thermal bands, NDBI, and NDVI, FV, EM\n    var optical = img.select(['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']);\n    var thermalBands = img.select(['B10', 'B11']);\n    var ndbi = img.normalizedDifference(['B6', 'B5']).rename('NDBI');\n    return lst.addBands([ndvi, fv, em, ndbi]).addBands(optical).addBands(thermalBands).copyProperties(img, img.propertyNames());\n  });\n\n  var mean = ee.Image(lstCollection.mean());\n  var bands = mean.bandNames();\n  var hasLST = bands.contains('LST');\n  return ee.Algorithms.If(hasLST, mean.clip(geom), ee.Image().rename('LST').clip(geom));\n}\n\n// Calculate LST for all polygons\nfunction calculateLST(feature) {\n  var dateString = ee.String(feature.get('dateright'));\n  var parts = dateString.split('-');\n  var year = ee.Number.parse(parts.get(0));\n  var month = ee.Number.parse(parts.get(1));\n  var day = ee.Number.parse(parts.get(2));\n  var constructDate = ee.Date.fromYMD(year, month, day);\n\n  var preStart = constructDate.advance(-3, 'year');\n  var preEnd = constructDate;\n  var postStart = constructDate.advance(1, 'year');\n  var postEnd = constructDate.advance(4, 'year');\n\n  var geom = feature.geometry();\n  var preImage = ee.Image(getLST(geom, preStart, preEnd));\n  var postImage = ee.Image(getLST(geom, postStart, postEnd));\n  var diff = postImage.select('LST').subtract(preImage.select('LST')).rename('LST_Difference');\n\n  // Reducers for LST calculations\n  var meanPreLSTDict = preImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanPostLSTDict = postImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanDiffDict = diff.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n\n  // Reducers for other indices for RF\n  var preOpticalDict = preImage.select(['NDVI', 'FV', 'EM', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: geom,\n    scale: 30,\n    maxPixels: 1e13\n  });\n\n  var meanPreLST = ee.Algorithms.If(meanPreLSTDict.contains('LST'), meanPreLSTDict.get('LST'), null);\n  var meanPostLST = ee.Algorithms.If(meanPostLSTDict.contains('LST'), meanPostLSTDict.get('LST'), null);\n  var meanDiff = ee.Algorithms.If(meanDiffDict.contains('LST_Difference'), meanDiffDict.get('LST_Difference'), null);\n\n  return feature.set({\n    'mean_preLST': meanPreLST,\n    'mean_postLST': meanPostLST,\n    'mean_LST_diff': meanDiff\n  }).set(preOpticalDict).setGeometry(feature.geometry());\n}\nvar results = polygons.map(calculateLST);\nGiven local government and resident concerns about PHVI’s impact on surrounding communities, we define a function called popBuffer to sum estimated populations within 730 metres of solar farms: a distance typically affected by PHVI (Guoqing et al., 2021).\n//Load population from Data For Good\nvar HRSL_total = ee.ImageCollection('projects/sat-io/open-datasets/hrsl/hrslpop').filterBounds(taiwan).median();\n\n//Vulnerable population: sum of 0-5 and 60+\nvar HRSL_0_5 = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_children_under_five\").filterBounds(taiwan).median();\nvar HRSL_60plus = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_elderly_over_sixty\").filterBounds(taiwan).median();\nvar HRSL_vulnerable = HRSL_0_5.add(HRSL_60plus).rename('HRSL_vulnerable');\n\n//Calculate population within 730m buffer\nfunction popBuffer(panel) {\n  var geom = panel.geometry().buffer(730);\n  var totalPop = ee.Number(HRSL_total.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('b1')).round();\n  var vulnerablePop = ee.Number(HRSL_vulnerable.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('HRSL_vulnerable')).round();\n  return panel.set({'total_buffer_pop': totalPop, 'vulnerable_buffer_pop': vulnerablePop});\n}\nvar all_results = results.map(popBuffer);\nFinally, due to their impact on LST (Šafanda, 1999), we load slope and elevation data and reduce these to the means for each solar polygon. We also calculate polygon areas in hectares.\n//Add extra non-Landsat features: elevation, topography, and polygon area\nvar srtm = ee.Image('USGS/SRTMGL1_003').clip(taiwan);\nvar elevation = srtm.select('elevation');\nvar slope = ee.Terrain.slope(srtm);\n\nvar allFeatures = validFeatures.map(function(feature) {\n  var geom = feature.geometry();\n  var meanElevation = elevation.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('elevation');\n  var meanSlope = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('slope');\n  var area = geom.area().divide(10000); //converting to ha as metres were overwhelming the model\n  return feature.set({\n    'elevation': meanElevation,\n    'slope': meanSlope,\n    'area': area});\n});\n\n\n\nAfter filtering all polygons to ensure they contain the necessary data, variables were extracted to conduct principal component analysis in Python to reduce dimensionality and prevent multicollinearity. The resultant random forest model is trained on 70% of the polygons, and has an R^2 of 0.79. It has a low RMSE and MAE relative to average temperature change, making it suitable for predicting changes in new sites.\n//Extract training data\nvar bands = test.select(['mean_preLST', 'mean_postLST', 'mean_LST_diff', 'NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area'])\n  .randomColumn();\n\n//Define test-train split\nvar split=0.7\nvar training_sample = bands.filter(ee.Filter.lt('random', split));\nvar validation_sample = bands.filter(ee.Filter.gte('random', split));\n\nprint('Sample training feature:', training_sample.first())\n\n//Set up RF\nvar model = ee.Classifier.smileRandomForest(100)\n  .setOutputMode('REGRESSION')\n  .train({\n    features: training_sample,\n    classProperty: 'mean_postLST',\n    //removed mean_preLST, EM, FV due to multicollinearity\n    inputProperties: ['NDVI', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area']});\nIf users are to select potential aquavoltaic installation sites, it is imperative that these are actually fish farms. We used a random forest model to identify existing fish farms based on Sentinel-2 imagery, drawing from Ballinger’s (2024) oil refinery identification. The model is trained and tested on manually drawn land identification polygons. The resulting prediction data was then manually cleaned in QGIS. In the prediction tab of the final application, the user’s polygon selection is required to intersect with a fish farm. While the model is not perfectly accurate, it sufficiently limits user input to areas with fish farms.\n\n// pre-process imagery\nvar start='2021-04-14';\nvar end='2025-04-14';\nvar bands = ['B2', 'B3', 'B4','B5','B6','B7','B8', 'B8A','B11','B12'];\n\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n                \nvar s_rgb = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nvar sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n  .filterBounds(AOI)\n  .filterDate(start, end)\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n  .select('VV')\n  .mean();\n\nvar ndvi=sentinel.normalizedDifference(['B8','B4']).select(['nd'],['ndvi']);\nvar ndwi=sentinel.normalizedDifference(['B3','B8']).select(['nd'],['ndwi'])\nvar newBands = ee.Image([ndwi,ndvi,sentinel1.rename('S1_VV')]);\nvar image=sentinel.addBands(newBands).clip(AOI);\n\n// add AOI and satellite imagery to map\nMap.addLayer(image.clip(AOI), s_rgb, 'Sentinel');\nMap.addLayer(AOI,null,\"AOI\",false);\n\n// select random points from each land type for training/validation\nvar fishfarm_points=ee.FeatureCollection.randomPoints(fishfarms, 3000).map(function(i){\n  return i.set({'class': 0})});\n  \nvar urban_points=ee.FeatureCollection.randomPoints(urban, 1000).map(function(i){\n  return i.set({'class': 1})});\n\n  \nvar river_points=ee.FeatureCollection.randomPoints(rivers, 2000).map(function(i){\n  return i.set({'class': 2})});  \n\nvar sample=ee.FeatureCollection([urban_points,\n                                  fishfarm_points,\n                                  river_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();\n\n// take samples from image for training and validation   \nvar split=0.7\nvar training_sample = sample.filter(ee.Filter.lt('random', split));\nvar validation_sample = sample.filter(ee.Filter.gte('random', split));\n\nvar training = image.sampleRegions({\n  collection: training_sample,\n  properties: ['class'],\n  scale: 10,\n});\n\nvar validation = image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// create model and run to create predictions\nvar model = ee.Classifier.smileRandomForest(400)\n.train(training, 'class');\n\nvar prediction = image.classify(model);\n\nvar fishfarm_prediction=prediction.updateMask(prediction.eq(0));\n\nMap.addLayer(fishfarm_prediction,{palette:'red'},'Predicted Fish Farms');\n\n// Assess accuracy of model\nvar validated = validation.classify(model);\n\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\nprint('Confusion Matrix ', testAccuracy);\nprint('Validation overall accuracy: ', testAccuracy.accuracy())\n\n\n\n\n\n\nThis code builds an interactive user interface (UI) in Google Earth Engine. It structures the app into two main parts: a Main Panel and a Map. The Main Panel includes two navigation buttons (to switch between exploring existing solar farms or predicting impacts for new sites), and a content container that updates to show either statistics, charts, and layer controls, or drawing tools for prediction.\n/*\nRoot\n├── Main Panel\n│   ├── Title\n│   ├── Button Panel\n│   │   ├── Visualize Button\n│   │   └── Predict Button\n│   └── Content Container\n│       ├── Visualize Content\n│       │   ├── Statistics Cards\n│       │   ├── Charts\n│       │   └── Layer Controls\n│       └── Predict Content\n│           ├── Drawing Tools\n│           └── Results Panel\n└── Map\n    ├── Base Layer\n    ├── Solar Panels Layer\n    ├── Fish Farms Layer\n    └── Population Layer\n*/\n\n// Clear UI and define core functions\nui.root.clear();\n\n// Initialize main UI components\nvar mainPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {width: '500px', padding: '10px'}\n});\n\nvar map = ui.Map();\nmap.setOptions('SATELLITE');\nmap.setCenter(120.10159388310306, 23.119258878572882, 13.5)\n\n//Add a legend\nvar legend = ui.Panel({style: {position: 'bottom-left', padding: '8px 15px'}});\nvar legendTitle = ui.Label({value: 'Temperature Difference (°C)', style: {fontWeight: 'bold', fontSize: '14px', margin: '0 0 4px 0'}});\nlegend.add(legendTitle);\n//Set visualisation parameters - same as polygons\nvar palette = palettes.colorbrewer.RdBu[9].reverse();\nvar min = -6;\nvar max = 6;\n//Set up colour bar\nvar colorBar = ui.Thumbnail({image: ee.Image.pixelLonLat().select(0).multiply((max - min) / 100.0).add(min)\n           .visualize({min: min, max: max, palette: palette}),\n  params: {bbox: [0, 0, 100, 10], dimensions: '100x10'},\n  style: {stretch: 'horizontal', margin: '0px 8px', maxHeight: '24px'}\n});\nlegend.add(colorBar);\n//Add labels\nvar legendLabels = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {margin: '1px 0 0 0'}\n});\nlegendLabels.add(ui.Label(min.toString(), {fontSize: '12px'}));\nlegendLabels.add(ui.Label(' ', {stretch: 'horizontal'})); // Spacer\nlegendLabels.add(ui.Label(max.toString(), {fontSize: '12px'}));\nlegend.add(legendLabels);\nmap.add(legend);\n\n// Create UI panels and buttons\nmainPanel.add(ui.Panel({\n  widgets: [ui.Label('Tainan Solar Farm Heat Impact App', \n    {fontWeight: 'bold', fontSize: '22px', margin: '0 0 10px 0', padding: '6px'})],\n  style: {padding: '0'}\n}));\n\n// Content panels\nvar visualizeContent = ui.Panel({style: {border: '1px solid #999', padding: '8px'}});\nvar predictedContent = ui.Panel({\n  widgets: [ui.Label('Still working', {fontSize: '16px', padding: '20px'})],\n  style: {border: '1px solid #999', padding: '8px'}\n});\n\n// Navigation buttons\nvar buttons = {\n  visualize: ui.Button({\n    label: 'Explore Existing Solar Farms',\n    onClick: function() {\n      showPanel(visualizeContent, buttons.visualize, buttons.predict);\n    },\n    style: {padding: '4px', fontWeight: 'bold', \n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  }),\n  predict: ui.Button({\n    label: 'Predict Change in a New Site',\n    onClick: function() {\n      showPanel(predictedContent, buttons.predict, buttons.visualize);\n    },\n    style: {padding: '4px', fontWeight: 'bold',\n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  })\n};\n// Button panel and container\nvar buttonPanel = ui.Panel([buttons.visualize, buttons.predict], \n  ui.Panel.Layout.flow('horizontal'), {margin: '0 0 20px 0'});\nvar contentContainer = ui.Panel();\n\n\n\nThis code builds a visualization interface to analyze solar farm impacts. It features three toggleable layers (solar panels, fish ponds, population estimates) managed by layerConfigs and createLayerControl. It displays solar farm counts, installation dates, statistic cards, and three charts. Users can interactively click farms for details and customize visible data through the control panel.\n//Set solar panel visualisation parameters\nvar solarStyle = {min: -6, max: 6, palette: palettes.colorbrewer.RdBu[9]}; //for some reason we don't reverse it bc we've already reversed the legend!\n\n//Reduce to image for faster loading\nvar solarImage = results.reduceToImage({properties: ['mean_LST_diff'], reducer: ee.Reducer.mean()}).rename('mean_LST_diff');\n\n//Add outlines so users can later select polygons\nvar outlinedPolygons = results.style({color: 'black', fillColor: '00000000', width: 0.5});\nMap.addLayer(outlinedPolygons, {}, 'Polygon Outlines');\n\n// define layerConfigs\nvar layerConfigs = {\n  'Solar Panels': {\n    layer: solarImage,\n    defaultVisible: true,\n    visParams: solarStyle,\n    type: 'raster'\n  },\n  \n  'Fish Farms': {\n    layer: fishfarms,\n    defaultVisible: false,\n    visParams: {\n      color: 'blue',\n      fillColor: '#87CEEB88',\n      width: 0\n    },\n    type: 'vector'\n  },\n  'Population Estimates': {\n    layer: HRSL_total, //.select('b1'),\n    defaultVisible: false,\n    visParams: {\n      min: 0,\n      max: 16,\n      palette: ['#A902A9'], //just a single colour, we don't want to complicate visualisation by having different pop colours too\n      opacity: 0.5},\n    type: 'raster'}\n};\n\n// define layer cache\nvar layerCache = {};\n\n// define layer order for UI display\nvar uiLayerOrder = [\n  'Solar Panels',\n  'Fish Farms',\n  'Population Estimates'\n];\n\n// define layer order for map display\nvar layerOrder = {\n  'Fish Farms': 1,\n  'Population Estimates': 2,\n  'Solar Panels': 3\n};\n\n//Add general instructions first\nvisualizeContent.add(ui.Label('Welcome!', {fontWeight:'bold', fontSize:'18px'}));\nvisualizeContent.add(ui.Label(\n  'This app uses satellite imagery to explore how solar farms influence local temperatures and communities.\\n\\n' +\n  'Use the map and this Explore tab to get a broad understanding of solar farm impacts. Click on a solar farm on the map to get more information about it. Finally, visit the Prediction tab to assess the potential effects of building a new solar farm in a location of your choice.',\n  {whiteSpace: 'pre-line'}\n));\n\n// add layer control to visualizeContent\nvisualizeContent.add(ui.Label('Select Data to Display:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\nuiLayerOrder.forEach(function(layerName) {\n  visualizeContent.add(createLayerControl(layerName));\n});\n\n// add Summary Statistics panel\nvisualizeContent.add(ui.Label('Overview:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n//Add total polygon numbers\nvar totalPanelsLabel = ui.Label('Loading total polygons count...', {\n  fontSize: '14px',\n  color: 'gray'});\nvisualizeContent.add(totalPanelsLabel);\n\ntotalPanels.evaluate(function(count) { //replace when calculated\n  visualizeContent.remove(totalPanelsLabel);\n  var boldLabel = ui.Label(String(count), {\n    fontSize: '15px', fontWeight: 'bold', color: 'black', padding: '0', margin: '0 4px 0 0'});\n  var regularLabel = ui.Label(' solar farms installed since March 2019.', {\n    fontSize: '15px', color: 'black', padding: '0', margin: '0'});\n  //Use a panel to make sure they're added next to each other\n  var labelPanel = ui.Panel({\n    widgets: [boldLabel, regularLabel],\n    layout: ui.Panel.Layout.flow('horizontal'),\n    style: {padding: '0', margin: '4px'}});\n  visualizeContent.widgets().insert(7, labelPanel); //make sure it's added in same position as before - ChatGPT helped\n});\n\n//Add summary statistics\nvar statCardsPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '10px 0'}\n});\n\n//Add a loading screen before the stats are calculated\nvar loadingCard = ui.Label('Loading maximum, minimum, and average temperature change...', {\n  fontSize: '14px',\n  color: 'gray',\n});\nstatCardsPanel.add(loadingCard);\n\nfunction createStatCard(label, value, color,textColor) {\n  return ui.Panel([\n    ui.Label(label, {\n      fontWeight: 'bold',\n      fontSize: '14px',\n      color: textColor,\n      backgroundColor: color\n    }),\n    ui.Label(value, {\n      fontSize: '18px',\n      color: textColor,\n      backgroundColor: color\n    })\n  ], ui.Panel.Layout.flow('vertical'), {\n    padding: '10px',\n    backgroundColor: color,\n    borderRadius: '8px',\n    margin: '4px',\n    width: '30%'\n  });\n}\n\n//Add Stat Cards in the order: min, max, average\nminTempChange.evaluate(function(min) {\n  statCardsPanel.clear(); //remove the loading bit\n  statCardsPanel.add(createStatCard('Min Temp Change', min.toFixed(2) + ' °C', '#2166ac','white'));\n  \n  averageTempChange.evaluate(function(avg) {\n    statCardsPanel.add(createStatCard('Avg Temp Change', avg.toFixed(2) + ' °C', '#f7f7f7','black'));\n\n    maxTempChange.evaluate(function(max) {\n      statCardsPanel.add(createStatCard('Max Temp Change', max.toFixed(2) + ' °C', '#b2182b','white'));\n    });\n  });\n});\nvisualizeContent.add(statCardsPanel);\n\n// add chart label and container\nvisualizeContent.add(ui.Label('Deeper Trends:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n// Create charts directly\nvar tempDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'mean_LST_diff',\n  minBucketWidth: 0.1\n}).setOptions({\n  title: 'What is the distribution of temperature change?',\n  hAxis: {title: 'Temperature Change (°C)'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#FE8789']\n});\n\nvar popDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'total_buffer_pop',\n  minBucketWidth: 50\n}).setOptions({\n  title: 'How many people typically live near a solar farm?',\n  hAxis: {title: 'Total Population Within 730m'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#A902A9']\n});\n\nvar nicerName = allFeatures.map(function(feature) { //improve appearance\n  return feature.set('Temperature Change (°C)', feature.get('mean_LST_diff'));\n});\n\nvar tempVsAreaChart = ui.Chart.feature.byFeature(\n  nicerName.filter(ee.Filter.notNull(['area', 'Temperature Change (°C)'])),\n  'area',\n  'Temperature Change (°C)'\n).setChartType('ScatterChart')\n .setOptions({\n   title: 'Is there a relationship between solar farm area and temperature?',\n   hAxis: {\n     title: 'Logged Area (hectares)',\n     scaleType: 'log',\n     format: 'short'\n   },\n   vAxis: {\n     title: 'Temperature Change (°C)',\n     viewWindow: {\n       min: -1,\n       max: 5\n     }\n   },\n   pointSize: 1,\n   colors: ['#ff8800'],\n   legend: {position: 'none'},\n   chartArea: {width: '85%', height: '80%'},\n   series: {0: {labelInLegend: 'Temp Change (°C)'}}\n });\n\n// Create a container for all charts\nvar chartsContainer = ui.Panel({\n  style: {margin: '10px 0'}\n});\n\n// Add charts to the container\nvisualizeContent.add(tempDistChart);\nvisualizeContent.add(popDistChart);\nvisualizeContent.add(tempVsAreaChart);\n\n\n//add disclaimer\nvisualizeContent.add(ui.Label(\n  'Please note that charts and summary statistics are based on a random sample of all solar farms. Although they closely reflect overall trends, exact values may vary slightly.',\n  {fontSize: '13px', fontStyle: 'italic'}));\n\n// then define createLayerControl function\nfunction createLayerControl(layerName) {\n  var config = layerConfigs[layerName];\n  \n  function createLayer() {\n    if (config.type === 'vector') {\n      return ui.Map.Layer({\n        eeObject: config.layer.style(config.visParams),\n        name: layerName,\n        shown: config.defaultVisible\n      });\n    }\n    return ui.Map.Layer({\n      eeObject: config.layer,\n      visParams: config.visParams,\n      name: layerName,\n      shown: config.defaultVisible\n    });\n  }\n\n  var checkbox = ui.Checkbox({\n    label: layerName,\n    value: config.defaultVisible,\n    onChange: function(checked) {\n      if (!layerCache[layerName]) {\n        layerCache[layerName] = createLayer();\n      }\n      \n      layerCache[layerName].setShown(checked);\n\n      // Add logic to link solar panel outlines (i.e. features) to the coloured panels (images) - ChatGPT helped here\n      if (layerName === 'Solar Panels') {\n        if (checked) {\n          layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n        } else {\n          layerCache['Polygon Outlines'] = null;\n        }\n      }\n\n      var visibleLayers = [];\n      // Sort layers by layerOrder\n      var sortedLayers = Object.keys(layerConfigs).sort(function(a, b) {\n        return layerOrder[a] - layerOrder[b];\n      });\n      \n      sortedLayers.forEach(function(name) {\n        if (layerCache[name] && layerCache[name].getShown()) {\n          visibleLayers.push(layerCache[name]);\n        }\n\n        //Again, ensure solar panel outlines are being shown if solar panels are\n        if (name === 'Solar Panels' && layerCache['Polygon Outlines']) {\n          visibleLayers.push(layerCache['Polygon Outlines']);\n        }\n      });\n\n      map.layers().reset(visibleLayers);\n    }\n  });\n\n  //Default load solar panel outlines, even though we don't want this to be shown in the UI\n  if (config.defaultVisible) {\n    layerCache[layerName] = createLayer();\n    map.add(layerCache[layerName]);\n\n    if (layerName === 'Solar Panels') {\n      layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n      map.add(layerCache['Polygon Outlines']);\n    }\n  }\n\n  return ui.Panel([checkbox], ui.Panel.Layout.flow('horizontal'));\n}\n\n// craete cache function\nvar chartCache = {\n  visualizeContent: null,\n  charts: []\n};\n\n// showPanel function\nfunction showPanel(panel, activeButton, inactiveButton) {\n  // hide all panels\n  visualizeContent.style().set('shown', false);\n  predictedContent.style().set('shown', false);\n  \n  // show the selected panel\n  if (panel === visualizeContent) {\n    visualizeContent.style().set('shown', true);\n    contentContainer.add(visualizeContent);\n  } else {\n    predictedContent.style().set('shown', true);\n    contentContainer.add(predictedContent);\n  }\n  \n  activeButton.style().set({fontWeight: 'bold'});\n  inactiveButton.style().set({fontWeight: 'bold'});\n}\n\n// Assemble UI and initialize\nmainPanel.add(buttonPanel);\nmainPanel.add(contentContainer);\n\n// Feature to click on solar farm polygons for more info:\nvar panel = null;\nvar highlightLayer = null;\n\n// Add map click handler\nmap.onClick(function(coords) {\n  var point = ee.Geometry.Point(coords.lon, coords.lat);\n  \n  // remove existing panel/highlight\n  if (panel !== null) {\n    map.remove(panel);\n    panel = null;\n  }\n  \n  if (highlightLayer !== null) {\n    map.remove(highlightLayer);\n    highlightLayer = null;\n  }\n  \n  // create panel\n  panel = ui.Panel({\n    style: {\n      position: 'top-right',\n      padding: '8px',\n      width: '320px',\n      backgroundColor: 'rgba(25, 25, 25, 0.8)'\n    }\n  });\n  \n  //define button to close the pop-up\n  var closeButton = ui.Button({\n    label: 'Close Panel',\n    style: {margin: '4px', backgroundColor: '00000000'}, //color: 'white'},\n    onClick: function() {\n      map.remove(panel);\n      panel = null;\n      if (highlightLayer !== null) {\n        map.remove(highlightLayer);\n        highlightLayer = null;\n      }\n    }\n  });\n\n  // show initial loading panel so the user knows something's happening\n  panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n       .add(ui.Label('Calculating...', {color: 'white', backgroundColor: '00000000'}));\n\n  map.add(panel);\n  \n  // extract properties from all_results\n  var featureWithArea = all_results\n  .filterBounds(point)\n  .map(function(f) {\n    return f.set('area_hectare', f.geometry().area().divide(1e6));\n  })\n  .first();\n\n  featureWithArea.evaluate(function(feature) { \n    //in case the user didn't select a panel\n    if (!feature) {\n      panel.clear();\n      panel.add(ui.Label('There are no solar farms at this location. Please select a new site.', \n      {fontSize: '16px', color: 'white', backgroundColor: '00000000'}))\n      .add(closeButton);\n      return;\n    }\n\n    // draw outline of selected feature\n    var geom = ee.Feature(feature).geometry();\n    highlightLayer = ui.Map.Layer(geom, {color: 'yellow', fillColor: '00000000', width: 3}, 'Selected Area');\n    map.add(highlightLayer);\n    \n    //extract properties from all_results\n    var props = feature.properties;\n  \n    // Update panel with actual info\n    panel.clear();\n    panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Installation date: ' + props.dateright, {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Average temperature change: ' + props.mean_LST_diff.toFixed(2) + '°C', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Area: ' + props.area_hectare.toFixed(2) + ' hectares', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Potential population affected: ' + props.total_buffer_pop, {color: 'white', backgroundColor: '00000000'}))\n         .add(closeButton);\n  });\n});\n\n\n\nThis section implements a prediction interface for analyzing the impact of solar farms on temperature and population. The main features include:\n\nDrawing Tools: users can draw a polygon on the map to select an area of interest.\nPrediction Processing: the model calculates temperature and population changes based on the selected area.\nResults Display: the interface shows the predicted temperature change, potential population affected, and a detailed summary of the results.\n\n// Initialize default view\nshowPanel(visualizeContent, buttons.visualize, buttons.predict);\n\n// Add to UI root\nui.root.add(ui.Panel([mainPanel, map], ui.Panel.Layout.flow('horizontal'), \n  {width: '100%', height: '100%'}));\n\n// clear the predictedContent\npredictedContent.clear();\n\n// add a description label\npredictedContent.add(ui.Label('To explore the effects of building a solar farm in a new site, please click the button below and draw a polygon on the map. Please make sure you draw the panel over a fish farm.', \n  {fontSize: '14px', margin: '0 0 10px 0'}));\n\n//Add button to draw the polygons\nvar drawButton = ui.Button({\n  label: 'Draw a new solar farm',\n  onClick: function() {\n    // clear the previous drawing\n    map.drawingTools().layers().reset();\n    map.drawingTools().setShape('polygon');\n    map.drawingTools().draw();\n    \n    // Disable the draw button and prevent further drawing\n    drawButton.setDisabled(true);\n    \n    // Start drawing and disable the drawing tools until drawing is complete\n    map.drawingTools().setShown(false);\n  },\n  style: {margin: '0 0 10px 0'}\n});\npredictedContent.add(drawButton);\n\n// add a results panel\nvar resultsPanel = ui.Panel({\n  style: {\n    margin: '10px 0',\n    padding: '5px',\n    border: '1px solid #ddd',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n    shown: false\n  }\n});\npredictedContent.add(resultsPanel);\n\n// add a loading label to the predictedContent\nvar loadingLabel = ui.Label('Please wait while the model runs...', {\n  fontStyle: 'italic',\n  fontSize: '15px',\n  //color: '#1a73e8',\n  margin: '10px 0',\n  shown: false\n});\npredictedContent.add(loadingLabel);\n\n// Create a small text label to appear under the results panel\nvar modelInfo = ui.Label('Please be aware that although the model is a useful tool, its predictions are unlikely to be perfectly accurate. The model explains 79% of variation in temperature change, with an average error of approximately 0.33°C.', {\n\n  shown:false\n});\npredictedContent.add(modelInfo);\n\n// Modify the map drawing completion event processing\nmap.drawingTools().onDraw(function(geometry) {\n  resultsPanel.clear();\n  loadingLabel.style().set('shown', true);  // show the loading label\n  modelInfo.style().set('shown', false); //ensure model explanation and results panel are hidden, even if they were shown before\n  resultsPanel.style().set('shown', false);\n  \n  //Only run if there is some intersection with fishfarms\n  var intersection = fishfarms.filterBounds(geometry).size().gt(0);\n  \n  intersection.evaluate(function(intersects) {\n    if (intersects) {\n\n    //Slightly changed version of the original analysis - does all calculations simultaneously to reduce waiting time\n      var computeScale = 30;\n      var feature = ee.Feature(geometry);\n      var pop = popBuffer(feature); //run pop function from above\n      var now = ee.Date(Date.now());\n      var polygonStart = now.advance(-3, 'year');\n      var polygonEnd = now;\n      var currentImage = ee.Image(getLST(geometry, polygonStart, polygonEnd)); //run LST calculation from above\n      var allComputations = ee.Dictionary({});\n\n      // perform the calculations separately and merge the results\n      var lstDict = currentImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var indicesDict = currentImage.select(['NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n        reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var elevationDict = elevation.reduceRegion({reducer: ee.Reducer.mean(),geometry: geometry,scale: computeScale, maxPixels: 1e13});\n      var slopeDict = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n\n      // Combine all the results\n      var combinedResults = ee.Dictionary(lstDict)\n        .combine(indicesDict)\n        .combine(elevationDict)\n        .combine(slopeDict)\n        .combine(pop.toDictionary(['total_buffer_pop', 'vulnerable_buffer_pop', 'child_buffer_pop', 'elderly_buffer_pop']));\n\n      combinedResults.evaluate(function(results) {\n        if (results.LST !== null) {\n          var currentLST = results.LST;\n          \n          //Create finished feature\n          var predictionFeature = ee.Feature(geometry, {\n            'NDVI': results.NDVI,\n            'NDBI': results.NDBI,\n            'B1': results.B1,\n            'B2': results.B2,\n            'B3': results.B3,\n            'B4': results.B4,\n            'B5': results.B5,\n            'B6': results.B6,\n            'B7': results.B7,\n            'B10': results.B10,\n            'B11': results.B11,\n            'elevation': results.elevation,\n            'slope': results.slope,\n            'area': geometry.area().divide(10000)});\n          \n          //Predict using model\n          var predicted = ee.FeatureCollection([predictionFeature]).classify(model);\n          predicted.first().get('classification').evaluate(function(futureTemp) {\n            var tempDiff = futureTemp - currentLST;\n            \n            //Hide loading label\n            loadingLabel.style().set('shown', false);\n            \n            //Print results\n            resultsPanel.style().set('shown', true);\n            resultsPanel.widgets().reset([ \n              ui.Label('Site Summary：', {fontWeight: 'bold', margin: '0 0 8px 0'}),\n              ui.Label('Current temperature：' + currentLST.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature with solar farm：' + futureTemp.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature change：' + tempDiff.toFixed(2) + '°C'),\n              ui.Label('Potential population affected：' + (results.total_buffer_pop || 0) + ' people'),\n              ui.Label('Potential vulnerable population affected：' + (results.vulnerable_buffer_pop || 0) + ' people'),\n              ui.Label('Populations are calculated within 730m of the polygon. Vulnerable population refers to estimated numbers of children (0-5) and elderly (60+) individuals living within this area.', {\n                  fontSize: '12px', fontStyle: 'italic'})\n            ]);\n            modelInfo.style().set('shown', true); \n            drawButton.setDisabled(false);\n            \n          });\n        } else {\n          loadingLabel.style().set('shown', false);\n          resultsPanel.style().set('shown', true);\n          resultsPanel.add(ui.Label('There is insufficient satellite imagery to calculate temperature for this location. Please select a different area.'));\n          drawButton.setDisabled(false);\n        }\n      });\n    } else {\n      loadingLabel.style().set('shown', false);\n      resultsPanel.style().set('shown', true);\n      resultsPanel.add(ui.Label('This polygon does not intersect with any fish farms. Please redraw in a different location.'));\n      drawButton.setDisabled(false);\n    }\n\n    //Stop and hide drawing tools once processing is finished\n    map.drawingTools().stop();\n    map.drawingTools().setShown(false);\n  });\n});\n\n\n\n\nFinal app\nGithHub repository\n\n\n\n\nBallinger, O. (1 January 2024) Refinery Identification [Module content], Building Spatial Applications with Big Data CASA0025, University College London.\nGuoqing, L., Hernandez, R.R., Blackburn, G.A., Davies, G., Hunt, M., Whyatt, J.D. and Armstrong, A., 2021. Ground-mounted photovoltaic solar parks promote land surface cool islands in arid ecosystems. Renewable and Sustainable Energy Transition, 1, p.100008.\nHsiao, Y.J., Chen, J.L. and Huang, C.T., 2021. What are the challenges and opportunities in implementing Taiwan’s aquavoltaics policy? A roadmap for achieving symbiosis between small-scale aquaculture and photovoltaics. Energy Policy, 153, p.112264.\nŠafanda, J., 1999. Ground surface temperature as a function of slope angle and slope orientation and its effect on the subsurface temperature field. Tectonophysics, 306(3-4), pp.367-375.\nUSGS, 2019. Landsat 8 (L8) Data Users Handbook. Obtained from https://d9-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/atoms/files/LSDS-1574_L8_Data_Users_Handbook-v5.0.pdf\nXu, Z., Li, Y., Qin, Y. and Bach, E., 2024. A global assessment of the effects of solar farms on albedo, vegetation, and land surface temperature using remote sensing. Solar Energy, 268, p.112198. https://doi.org/10.1016/j.solener.2023.112198"
  },
  {
    "objectID": "solar_panel.html#project-summary",
    "href": "solar_panel.html#project-summary",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Although renewable energy is crucial to meeting Taiwan’s Net Zero goals, land availability represents a critical constraint (Hsiao et al., 2021). To address this, the Taiwanese government has implemented an aquavoltaics programme, integrating solar panels into fish farms to generate space-efficient energy. However, this initiative faces significant local opposition, with some authorities even banning construction due to concerns about socio-environmental impacts such as temperature increases, known as the photovoltaic heat island effect (PHVI). There is a clear need for an accessible, evidence-based participatory planning tool to resolve local conflicts, overcome planning roadblocks, and provide a foundation for informed programme expansion.\n\n\n\n\n\n\n\nThis application serves as a participatory planning tool to overcome conflicts between stakeholders with opposing perspectives on aquavoltaic expansion. It does this by openly exploring the PHVI impacts of past and prospective solar sites. Alongside expediting planning, helping mitigate local impacts, and supporting Taiwan’s Net Zero goals, additional benefits for each stakeholder are outlined below:\n\nNational government: communicating policy; mitigating unfounded concerns.\nLocal government: evidence-based assessment of past projects; informed future planning within jurisdictions.\nFish farmers: presenting a case for having solar panels installed on their sites.\nLocal residents: reducing concerns; empowering them to challenge decisions at higher governance levels.\n\n\n\n\n\nLandsat 8 Collection 1 Top of Atmosphere imagery at 30m resolution for temperature change assessments.\nSentinel-2 imagery at 10m resolution for fish farm identification.\nSolar panel polygons and construction dates from the Taiwanese Civil Service..\nPopulation estimates at 30m resolution from Meta’s Data for Good\nDigital elevation data at 30m resolution from the NASA Shuttle Radar Topography Mission.\n\n\n\n\nFirst, land surface temperature (LST) before and after solar panel installation is calculated using the method detailed by Xu et al., (2024), which averages satellite images for a period of three years before and after construction of the solar panel. A random forest model uses these changes, alongside optical and thermal imagery, slope, and elevation to predict temperature impacts at other sites. A second random forest identifies fish farms, ensuring users can only select prospective sites which could be included in the programme. Finally, predicted temperature change and local population estimates indicate the impact of developments on local communities.\n\n\n\nThe application provides a transparent, accessible tool to foster communication, improve collaboration, and bring clarity to a contentious issue. The interface is divided into two: the Explore tab provides a broad overview of PHVI impacts through summary statistics and charts, while the Predict tab enables site-specific predictions, allowing users to tailor insights to their local context. Users can click on solar farms to receive a summary at any point, either supplementing the overview or facilitating comparisons with prospective sites. A blue-to-red colour scheme intuitively communicates temperature changes, and clear chart titles and disclaimers ensure the analysis is understandable and transparent."
  },
  {
    "objectID": "solar_panel.html#how-it-works",
    "href": "solar_panel.html#how-it-works",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "First, the data collection is filtered with a 25% cloud cover threshold and mean pixel values are calculated for a period of 3 years pre- and post-construction of the solar panel. LST is calculated using the following equation: LST = (BT / (1 + (0.00115 * (BT / 1.4388)) * Ln(ε))) found in the USGS handbook (2019). Other indices like NDVI and NDBI are also calculated in this step for the prediction model.\n// ------ LST Calculations ------\n\nfunction getLST(geom, start, end) {\n  var collection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA')\n    .filterBounds(geom)\n    .filterDate(start, end)\n    .filter(ee.Filter.lt('CLOUD_COVER',25));\n\n  var lstCollection = collection.map(function(img) {\n    var ndvi = img.normalizedDifference(['B5', 'B4']).rename('NDVI');\n    var fv = ndvi.subtract(0).divide(1 - 0).rename('FV');\n    var em = fv.multiply(0.004).add(0.986).rename('EM');\n    var thermal = img.select('B10');\n    var lst = thermal.expression(\n      '(Tb / (1 + (0.00115 * (Tb / 1.438)) * log(Ep))) - 273.15',\n      {\n        'Tb': thermal,\n        'Ep': em\n      }\n    ).rename('LST');\n\n    //Extra variables for the random forest: optical bands, thermal bands, NDBI, and NDVI, FV, EM\n    var optical = img.select(['B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7']);\n    var thermalBands = img.select(['B10', 'B11']);\n    var ndbi = img.normalizedDifference(['B6', 'B5']).rename('NDBI');\n    return lst.addBands([ndvi, fv, em, ndbi]).addBands(optical).addBands(thermalBands).copyProperties(img, img.propertyNames());\n  });\n\n  var mean = ee.Image(lstCollection.mean());\n  var bands = mean.bandNames();\n  var hasLST = bands.contains('LST');\n  return ee.Algorithms.If(hasLST, mean.clip(geom), ee.Image().rename('LST').clip(geom));\n}\n\n// Calculate LST for all polygons\nfunction calculateLST(feature) {\n  var dateString = ee.String(feature.get('dateright'));\n  var parts = dateString.split('-');\n  var year = ee.Number.parse(parts.get(0));\n  var month = ee.Number.parse(parts.get(1));\n  var day = ee.Number.parse(parts.get(2));\n  var constructDate = ee.Date.fromYMD(year, month, day);\n\n  var preStart = constructDate.advance(-3, 'year');\n  var preEnd = constructDate;\n  var postStart = constructDate.advance(1, 'year');\n  var postEnd = constructDate.advance(4, 'year');\n\n  var geom = feature.geometry();\n  var preImage = ee.Image(getLST(geom, preStart, preEnd));\n  var postImage = ee.Image(getLST(geom, postStart, postEnd));\n  var diff = postImage.select('LST').subtract(preImage.select('LST')).rename('LST_Difference');\n\n  // Reducers for LST calculations\n  var meanPreLSTDict = preImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanPostLSTDict = postImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n  var meanDiffDict = diff.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13});\n\n  // Reducers for other indices for RF\n  var preOpticalDict = preImage.select(['NDVI', 'FV', 'EM', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n    reducer: ee.Reducer.mean(),\n    geometry: geom,\n    scale: 30,\n    maxPixels: 1e13\n  });\n\n  var meanPreLST = ee.Algorithms.If(meanPreLSTDict.contains('LST'), meanPreLSTDict.get('LST'), null);\n  var meanPostLST = ee.Algorithms.If(meanPostLSTDict.contains('LST'), meanPostLSTDict.get('LST'), null);\n  var meanDiff = ee.Algorithms.If(meanDiffDict.contains('LST_Difference'), meanDiffDict.get('LST_Difference'), null);\n\n  return feature.set({\n    'mean_preLST': meanPreLST,\n    'mean_postLST': meanPostLST,\n    'mean_LST_diff': meanDiff\n  }).set(preOpticalDict).setGeometry(feature.geometry());\n}\nvar results = polygons.map(calculateLST);\nGiven local government and resident concerns about PHVI’s impact on surrounding communities, we define a function called popBuffer to sum estimated populations within 730 metres of solar farms: a distance typically affected by PHVI (Guoqing et al., 2021).\n//Load population from Data For Good\nvar HRSL_total = ee.ImageCollection('projects/sat-io/open-datasets/hrsl/hrslpop').filterBounds(taiwan).median();\n\n//Vulnerable population: sum of 0-5 and 60+\nvar HRSL_0_5 = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_children_under_five\").filterBounds(taiwan).median();\nvar HRSL_60plus = ee.ImageCollection(\"projects/sat-io/open-datasets/hrsl/hrsl_elderly_over_sixty\").filterBounds(taiwan).median();\nvar HRSL_vulnerable = HRSL_0_5.add(HRSL_60plus).rename('HRSL_vulnerable');\n\n//Calculate population within 730m buffer\nfunction popBuffer(panel) {\n  var geom = panel.geometry().buffer(730);\n  var totalPop = ee.Number(HRSL_total.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('b1')).round();\n  var vulnerablePop = ee.Number(HRSL_vulnerable.reduceRegion({reducer: ee.Reducer.sum(), geometry: geom, scale: 30, maxPixels: 1e13}).get('HRSL_vulnerable')).round();\n  return panel.set({'total_buffer_pop': totalPop, 'vulnerable_buffer_pop': vulnerablePop});\n}\nvar all_results = results.map(popBuffer);\nFinally, due to their impact on LST (Šafanda, 1999), we load slope and elevation data and reduce these to the means for each solar polygon. We also calculate polygon areas in hectares.\n//Add extra non-Landsat features: elevation, topography, and polygon area\nvar srtm = ee.Image('USGS/SRTMGL1_003').clip(taiwan);\nvar elevation = srtm.select('elevation');\nvar slope = ee.Terrain.slope(srtm);\n\nvar allFeatures = validFeatures.map(function(feature) {\n  var geom = feature.geometry();\n  var meanElevation = elevation.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('elevation');\n  var meanSlope = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geom, scale: 30, maxPixels: 1e13}).get('slope');\n  var area = geom.area().divide(10000); //converting to ha as metres were overwhelming the model\n  return feature.set({\n    'elevation': meanElevation,\n    'slope': meanSlope,\n    'area': area});\n});\n\n\n\nAfter filtering all polygons to ensure they contain the necessary data, variables were extracted to conduct principal component analysis in Python to reduce dimensionality and prevent multicollinearity. The resultant random forest model is trained on 70% of the polygons, and has an R^2 of 0.79. It has a low RMSE and MAE relative to average temperature change, making it suitable for predicting changes in new sites.\n//Extract training data\nvar bands = test.select(['mean_preLST', 'mean_postLST', 'mean_LST_diff', 'NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area'])\n  .randomColumn();\n\n//Define test-train split\nvar split=0.7\nvar training_sample = bands.filter(ee.Filter.lt('random', split));\nvar validation_sample = bands.filter(ee.Filter.gte('random', split));\n\nprint('Sample training feature:', training_sample.first())\n\n//Set up RF\nvar model = ee.Classifier.smileRandomForest(100)\n  .setOutputMode('REGRESSION')\n  .train({\n    features: training_sample,\n    classProperty: 'mean_postLST',\n    //removed mean_preLST, EM, FV due to multicollinearity\n    inputProperties: ['NDVI', 'NDBI', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11', 'elevation', 'slope', 'area']});\nIf users are to select potential aquavoltaic installation sites, it is imperative that these are actually fish farms. We used a random forest model to identify existing fish farms based on Sentinel-2 imagery, drawing from Ballinger’s (2024) oil refinery identification. The model is trained and tested on manually drawn land identification polygons. The resulting prediction data was then manually cleaned in QGIS. In the prediction tab of the final application, the user’s polygon selection is required to intersect with a fish farm. While the model is not perfectly accurate, it sufficiently limits user input to areas with fish farms.\n\n// pre-process imagery\nvar start='2021-04-14';\nvar end='2025-04-14';\nvar bands = ['B2', 'B3', 'B4','B5','B6','B7','B8', 'B8A','B11','B12'];\n\nvar sentinel = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')\n                  .filter(ee.Filter.date(start, end))\n                  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 10))\n                  .mean()\n                  .select(bands);\n                \nvar s_rgb = {\n  min: 0.0,\n  max: 3000,\n  bands:['B4', 'B3', 'B2'],\n  opacity:1\n};\n\nvar sentinel1 = ee.ImageCollection('COPERNICUS/S1_GRD')\n  .filterBounds(AOI)\n  .filterDate(start, end)\n  .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\n  .select('VV')\n  .mean();\n\nvar ndvi=sentinel.normalizedDifference(['B8','B4']).select(['nd'],['ndvi']);\nvar ndwi=sentinel.normalizedDifference(['B3','B8']).select(['nd'],['ndwi'])\nvar newBands = ee.Image([ndwi,ndvi,sentinel1.rename('S1_VV')]);\nvar image=sentinel.addBands(newBands).clip(AOI);\n\n// add AOI and satellite imagery to map\nMap.addLayer(image.clip(AOI), s_rgb, 'Sentinel');\nMap.addLayer(AOI,null,\"AOI\",false);\n\n// select random points from each land type for training/validation\nvar fishfarm_points=ee.FeatureCollection.randomPoints(fishfarms, 3000).map(function(i){\n  return i.set({'class': 0})});\n  \nvar urban_points=ee.FeatureCollection.randomPoints(urban, 1000).map(function(i){\n  return i.set({'class': 1})});\n\n  \nvar river_points=ee.FeatureCollection.randomPoints(rivers, 2000).map(function(i){\n  return i.set({'class': 2})});  \n\nvar sample=ee.FeatureCollection([urban_points,\n                                  fishfarm_points,\n                                  river_points\n                                  ])\n                                  .flatten()\n                                  .randomColumn();\n\n// take samples from image for training and validation   \nvar split=0.7\nvar training_sample = sample.filter(ee.Filter.lt('random', split));\nvar validation_sample = sample.filter(ee.Filter.gte('random', split));\n\nvar training = image.sampleRegions({\n  collection: training_sample,\n  properties: ['class'],\n  scale: 10,\n});\n\nvar validation = image.sampleRegions({\n  collection: validation_sample,\n  properties: ['class'],\n  scale: 10\n});\n\n// create model and run to create predictions\nvar model = ee.Classifier.smileRandomForest(400)\n.train(training, 'class');\n\nvar prediction = image.classify(model);\n\nvar fishfarm_prediction=prediction.updateMask(prediction.eq(0));\n\nMap.addLayer(fishfarm_prediction,{palette:'red'},'Predicted Fish Farms');\n\n// Assess accuracy of model\nvar validated = validation.classify(model);\n\nvar testAccuracy = validated.errorMatrix('class', 'classification');\n\nprint('Confusion Matrix ', testAccuracy);\nprint('Validation overall accuracy: ', testAccuracy.accuracy())\n\n\n\n\n\n\nThis code builds an interactive user interface (UI) in Google Earth Engine. It structures the app into two main parts: a Main Panel and a Map. The Main Panel includes two navigation buttons (to switch between exploring existing solar farms or predicting impacts for new sites), and a content container that updates to show either statistics, charts, and layer controls, or drawing tools for prediction.\n/*\nRoot\n├── Main Panel\n│   ├── Title\n│   ├── Button Panel\n│   │   ├── Visualize Button\n│   │   └── Predict Button\n│   └── Content Container\n│       ├── Visualize Content\n│       │   ├── Statistics Cards\n│       │   ├── Charts\n│       │   └── Layer Controls\n│       └── Predict Content\n│           ├── Drawing Tools\n│           └── Results Panel\n└── Map\n    ├── Base Layer\n    ├── Solar Panels Layer\n    ├── Fish Farms Layer\n    └── Population Layer\n*/\n\n// Clear UI and define core functions\nui.root.clear();\n\n// Initialize main UI components\nvar mainPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('vertical'),\n  style: {width: '500px', padding: '10px'}\n});\n\nvar map = ui.Map();\nmap.setOptions('SATELLITE');\nmap.setCenter(120.10159388310306, 23.119258878572882, 13.5)\n\n//Add a legend\nvar legend = ui.Panel({style: {position: 'bottom-left', padding: '8px 15px'}});\nvar legendTitle = ui.Label({value: 'Temperature Difference (°C)', style: {fontWeight: 'bold', fontSize: '14px', margin: '0 0 4px 0'}});\nlegend.add(legendTitle);\n//Set visualisation parameters - same as polygons\nvar palette = palettes.colorbrewer.RdBu[9].reverse();\nvar min = -6;\nvar max = 6;\n//Set up colour bar\nvar colorBar = ui.Thumbnail({image: ee.Image.pixelLonLat().select(0).multiply((max - min) / 100.0).add(min)\n           .visualize({min: min, max: max, palette: palette}),\n  params: {bbox: [0, 0, 100, 10], dimensions: '100x10'},\n  style: {stretch: 'horizontal', margin: '0px 8px', maxHeight: '24px'}\n});\nlegend.add(colorBar);\n//Add labels\nvar legendLabels = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {margin: '1px 0 0 0'}\n});\nlegendLabels.add(ui.Label(min.toString(), {fontSize: '12px'}));\nlegendLabels.add(ui.Label(' ', {stretch: 'horizontal'})); // Spacer\nlegendLabels.add(ui.Label(max.toString(), {fontSize: '12px'}));\nlegend.add(legendLabels);\nmap.add(legend);\n\n// Create UI panels and buttons\nmainPanel.add(ui.Panel({\n  widgets: [ui.Label('Tainan Solar Farm Heat Impact App', \n    {fontWeight: 'bold', fontSize: '22px', margin: '0 0 10px 0', padding: '6px'})],\n  style: {padding: '0'}\n}));\n\n// Content panels\nvar visualizeContent = ui.Panel({style: {border: '1px solid #999', padding: '8px'}});\nvar predictedContent = ui.Panel({\n  widgets: [ui.Label('Still working', {fontSize: '16px', padding: '20px'})],\n  style: {border: '1px solid #999', padding: '8px'}\n});\n\n// Navigation buttons\nvar buttons = {\n  visualize: ui.Button({\n    label: 'Explore Existing Solar Farms',\n    onClick: function() {\n      showPanel(visualizeContent, buttons.visualize, buttons.predict);\n    },\n    style: {padding: '4px', fontWeight: 'bold', \n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  }),\n  predict: ui.Button({\n    label: 'Predict Change in a New Site',\n    onClick: function() {\n      showPanel(predictedContent, buttons.predict, buttons.visualize);\n    },\n    style: {padding: '4px', fontWeight: 'bold',\n            border: '1px solid #dddddd', margin: '0 2px 0 0'}\n  })\n};\n// Button panel and container\nvar buttonPanel = ui.Panel([buttons.visualize, buttons.predict], \n  ui.Panel.Layout.flow('horizontal'), {margin: '0 0 20px 0'});\nvar contentContainer = ui.Panel();\n\n\n\nThis code builds a visualization interface to analyze solar farm impacts. It features three toggleable layers (solar panels, fish ponds, population estimates) managed by layerConfigs and createLayerControl. It displays solar farm counts, installation dates, statistic cards, and three charts. Users can interactively click farms for details and customize visible data through the control panel.\n//Set solar panel visualisation parameters\nvar solarStyle = {min: -6, max: 6, palette: palettes.colorbrewer.RdBu[9]}; //for some reason we don't reverse it bc we've already reversed the legend!\n\n//Reduce to image for faster loading\nvar solarImage = results.reduceToImage({properties: ['mean_LST_diff'], reducer: ee.Reducer.mean()}).rename('mean_LST_diff');\n\n//Add outlines so users can later select polygons\nvar outlinedPolygons = results.style({color: 'black', fillColor: '00000000', width: 0.5});\nMap.addLayer(outlinedPolygons, {}, 'Polygon Outlines');\n\n// define layerConfigs\nvar layerConfigs = {\n  'Solar Panels': {\n    layer: solarImage,\n    defaultVisible: true,\n    visParams: solarStyle,\n    type: 'raster'\n  },\n  \n  'Fish Farms': {\n    layer: fishfarms,\n    defaultVisible: false,\n    visParams: {\n      color: 'blue',\n      fillColor: '#87CEEB88',\n      width: 0\n    },\n    type: 'vector'\n  },\n  'Population Estimates': {\n    layer: HRSL_total, //.select('b1'),\n    defaultVisible: false,\n    visParams: {\n      min: 0,\n      max: 16,\n      palette: ['#A902A9'], //just a single colour, we don't want to complicate visualisation by having different pop colours too\n      opacity: 0.5},\n    type: 'raster'}\n};\n\n// define layer cache\nvar layerCache = {};\n\n// define layer order for UI display\nvar uiLayerOrder = [\n  'Solar Panels',\n  'Fish Farms',\n  'Population Estimates'\n];\n\n// define layer order for map display\nvar layerOrder = {\n  'Fish Farms': 1,\n  'Population Estimates': 2,\n  'Solar Panels': 3\n};\n\n//Add general instructions first\nvisualizeContent.add(ui.Label('Welcome!', {fontWeight:'bold', fontSize:'18px'}));\nvisualizeContent.add(ui.Label(\n  'This app uses satellite imagery to explore how solar farms influence local temperatures and communities.\\n\\n' +\n  'Use the map and this Explore tab to get a broad understanding of solar farm impacts. Click on a solar farm on the map to get more information about it. Finally, visit the Prediction tab to assess the potential effects of building a new solar farm in a location of your choice.',\n  {whiteSpace: 'pre-line'}\n));\n\n// add layer control to visualizeContent\nvisualizeContent.add(ui.Label('Select Data to Display:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\nuiLayerOrder.forEach(function(layerName) {\n  visualizeContent.add(createLayerControl(layerName));\n});\n\n// add Summary Statistics panel\nvisualizeContent.add(ui.Label('Overview:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n//Add total polygon numbers\nvar totalPanelsLabel = ui.Label('Loading total polygons count...', {\n  fontSize: '14px',\n  color: 'gray'});\nvisualizeContent.add(totalPanelsLabel);\n\ntotalPanels.evaluate(function(count) { //replace when calculated\n  visualizeContent.remove(totalPanelsLabel);\n  var boldLabel = ui.Label(String(count), {\n    fontSize: '15px', fontWeight: 'bold', color: 'black', padding: '0', margin: '0 4px 0 0'});\n  var regularLabel = ui.Label(' solar farms installed since March 2019.', {\n    fontSize: '15px', color: 'black', padding: '0', margin: '0'});\n  //Use a panel to make sure they're added next to each other\n  var labelPanel = ui.Panel({\n    widgets: [boldLabel, regularLabel],\n    layout: ui.Panel.Layout.flow('horizontal'),\n    style: {padding: '0', margin: '4px'}});\n  visualizeContent.widgets().insert(7, labelPanel); //make sure it's added in same position as before - ChatGPT helped\n});\n\n//Add summary statistics\nvar statCardsPanel = ui.Panel({\n  layout: ui.Panel.Layout.flow('horizontal'),\n  style: {stretch: 'horizontal', margin: '10px 0'}\n});\n\n//Add a loading screen before the stats are calculated\nvar loadingCard = ui.Label('Loading maximum, minimum, and average temperature change...', {\n  fontSize: '14px',\n  color: 'gray',\n});\nstatCardsPanel.add(loadingCard);\n\nfunction createStatCard(label, value, color,textColor) {\n  return ui.Panel([\n    ui.Label(label, {\n      fontWeight: 'bold',\n      fontSize: '14px',\n      color: textColor,\n      backgroundColor: color\n    }),\n    ui.Label(value, {\n      fontSize: '18px',\n      color: textColor,\n      backgroundColor: color\n    })\n  ], ui.Panel.Layout.flow('vertical'), {\n    padding: '10px',\n    backgroundColor: color,\n    borderRadius: '8px',\n    margin: '4px',\n    width: '30%'\n  });\n}\n\n//Add Stat Cards in the order: min, max, average\nminTempChange.evaluate(function(min) {\n  statCardsPanel.clear(); //remove the loading bit\n  statCardsPanel.add(createStatCard('Min Temp Change', min.toFixed(2) + ' °C', '#2166ac','white'));\n  \n  averageTempChange.evaluate(function(avg) {\n    statCardsPanel.add(createStatCard('Avg Temp Change', avg.toFixed(2) + ' °C', '#f7f7f7','black'));\n\n    maxTempChange.evaluate(function(max) {\n      statCardsPanel.add(createStatCard('Max Temp Change', max.toFixed(2) + ' °C', '#b2182b','white'));\n    });\n  });\n});\nvisualizeContent.add(statCardsPanel);\n\n// add chart label and container\nvisualizeContent.add(ui.Label('Deeper Trends:', {fontWeight: 'bold', fontSize: '16px', margin: '15px 0 5px 0'}));\n\n// Create charts directly\nvar tempDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'mean_LST_diff',\n  minBucketWidth: 0.1\n}).setOptions({\n  title: 'What is the distribution of temperature change?',\n  hAxis: {title: 'Temperature Change (°C)'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#FE8789']\n});\n\nvar popDistChart = ui.Chart.feature.histogram({\n  features: sample,\n  property: 'total_buffer_pop',\n  minBucketWidth: 50\n}).setOptions({\n  title: 'How many people typically live near a solar farm?',\n  hAxis: {title: 'Total Population Within 730m'},\n  vAxis: {title: 'Number of Solar Farms'},\n  legend: {position: 'none'},\n  colors: ['#A902A9']\n});\n\nvar nicerName = allFeatures.map(function(feature) { //improve appearance\n  return feature.set('Temperature Change (°C)', feature.get('mean_LST_diff'));\n});\n\nvar tempVsAreaChart = ui.Chart.feature.byFeature(\n  nicerName.filter(ee.Filter.notNull(['area', 'Temperature Change (°C)'])),\n  'area',\n  'Temperature Change (°C)'\n).setChartType('ScatterChart')\n .setOptions({\n   title: 'Is there a relationship between solar farm area and temperature?',\n   hAxis: {\n     title: 'Logged Area (hectares)',\n     scaleType: 'log',\n     format: 'short'\n   },\n   vAxis: {\n     title: 'Temperature Change (°C)',\n     viewWindow: {\n       min: -1,\n       max: 5\n     }\n   },\n   pointSize: 1,\n   colors: ['#ff8800'],\n   legend: {position: 'none'},\n   chartArea: {width: '85%', height: '80%'},\n   series: {0: {labelInLegend: 'Temp Change (°C)'}}\n });\n\n// Create a container for all charts\nvar chartsContainer = ui.Panel({\n  style: {margin: '10px 0'}\n});\n\n// Add charts to the container\nvisualizeContent.add(tempDistChart);\nvisualizeContent.add(popDistChart);\nvisualizeContent.add(tempVsAreaChart);\n\n\n//add disclaimer\nvisualizeContent.add(ui.Label(\n  'Please note that charts and summary statistics are based on a random sample of all solar farms. Although they closely reflect overall trends, exact values may vary slightly.',\n  {fontSize: '13px', fontStyle: 'italic'}));\n\n// then define createLayerControl function\nfunction createLayerControl(layerName) {\n  var config = layerConfigs[layerName];\n  \n  function createLayer() {\n    if (config.type === 'vector') {\n      return ui.Map.Layer({\n        eeObject: config.layer.style(config.visParams),\n        name: layerName,\n        shown: config.defaultVisible\n      });\n    }\n    return ui.Map.Layer({\n      eeObject: config.layer,\n      visParams: config.visParams,\n      name: layerName,\n      shown: config.defaultVisible\n    });\n  }\n\n  var checkbox = ui.Checkbox({\n    label: layerName,\n    value: config.defaultVisible,\n    onChange: function(checked) {\n      if (!layerCache[layerName]) {\n        layerCache[layerName] = createLayer();\n      }\n      \n      layerCache[layerName].setShown(checked);\n\n      // Add logic to link solar panel outlines (i.e. features) to the coloured panels (images) - ChatGPT helped here\n      if (layerName === 'Solar Panels') {\n        if (checked) {\n          layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n        } else {\n          layerCache['Polygon Outlines'] = null;\n        }\n      }\n\n      var visibleLayers = [];\n      // Sort layers by layerOrder\n      var sortedLayers = Object.keys(layerConfigs).sort(function(a, b) {\n        return layerOrder[a] - layerOrder[b];\n      });\n      \n      sortedLayers.forEach(function(name) {\n        if (layerCache[name] && layerCache[name].getShown()) {\n          visibleLayers.push(layerCache[name]);\n        }\n\n        //Again, ensure solar panel outlines are being shown if solar panels are\n        if (name === 'Solar Panels' && layerCache['Polygon Outlines']) {\n          visibleLayers.push(layerCache['Polygon Outlines']);\n        }\n      });\n\n      map.layers().reset(visibleLayers);\n    }\n  });\n\n  //Default load solar panel outlines, even though we don't want this to be shown in the UI\n  if (config.defaultVisible) {\n    layerCache[layerName] = createLayer();\n    map.add(layerCache[layerName]);\n\n    if (layerName === 'Solar Panels') {\n      layerCache['Polygon Outlines'] = ui.Map.Layer(outlinedPolygons, {}, 'Polygon Outlines');\n      map.add(layerCache['Polygon Outlines']);\n    }\n  }\n\n  return ui.Panel([checkbox], ui.Panel.Layout.flow('horizontal'));\n}\n\n// craete cache function\nvar chartCache = {\n  visualizeContent: null,\n  charts: []\n};\n\n// showPanel function\nfunction showPanel(panel, activeButton, inactiveButton) {\n  // hide all panels\n  visualizeContent.style().set('shown', false);\n  predictedContent.style().set('shown', false);\n  \n  // show the selected panel\n  if (panel === visualizeContent) {\n    visualizeContent.style().set('shown', true);\n    contentContainer.add(visualizeContent);\n  } else {\n    predictedContent.style().set('shown', true);\n    contentContainer.add(predictedContent);\n  }\n  \n  activeButton.style().set({fontWeight: 'bold'});\n  inactiveButton.style().set({fontWeight: 'bold'});\n}\n\n// Assemble UI and initialize\nmainPanel.add(buttonPanel);\nmainPanel.add(contentContainer);\n\n// Feature to click on solar farm polygons for more info:\nvar panel = null;\nvar highlightLayer = null;\n\n// Add map click handler\nmap.onClick(function(coords) {\n  var point = ee.Geometry.Point(coords.lon, coords.lat);\n  \n  // remove existing panel/highlight\n  if (panel !== null) {\n    map.remove(panel);\n    panel = null;\n  }\n  \n  if (highlightLayer !== null) {\n    map.remove(highlightLayer);\n    highlightLayer = null;\n  }\n  \n  // create panel\n  panel = ui.Panel({\n    style: {\n      position: 'top-right',\n      padding: '8px',\n      width: '320px',\n      backgroundColor: 'rgba(25, 25, 25, 0.8)'\n    }\n  });\n  \n  //define button to close the pop-up\n  var closeButton = ui.Button({\n    label: 'Close Panel',\n    style: {margin: '4px', backgroundColor: '00000000'}, //color: 'white'},\n    onClick: function() {\n      map.remove(panel);\n      panel = null;\n      if (highlightLayer !== null) {\n        map.remove(highlightLayer);\n        highlightLayer = null;\n      }\n    }\n  });\n\n  // show initial loading panel so the user knows something's happening\n  panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n       .add(ui.Label('Calculating...', {color: 'white', backgroundColor: '00000000'}));\n\n  map.add(panel);\n  \n  // extract properties from all_results\n  var featureWithArea = all_results\n  .filterBounds(point)\n  .map(function(f) {\n    return f.set('area_hectare', f.geometry().area().divide(1e6));\n  })\n  .first();\n\n  featureWithArea.evaluate(function(feature) { \n    //in case the user didn't select a panel\n    if (!feature) {\n      panel.clear();\n      panel.add(ui.Label('There are no solar farms at this location. Please select a new site.', \n      {fontSize: '16px', color: 'white', backgroundColor: '00000000'}))\n      .add(closeButton);\n      return;\n    }\n\n    // draw outline of selected feature\n    var geom = ee.Feature(feature).geometry();\n    highlightLayer = ui.Map.Layer(geom, {color: 'yellow', fillColor: '00000000', width: 3}, 'Selected Area');\n    map.add(highlightLayer);\n    \n    //extract properties from all_results\n    var props = feature.properties;\n  \n    // Update panel with actual info\n    panel.clear();\n    panel.add(ui.Label('Solar Farm Summary:', {fontSize: '16px', fontWeight: 'bold', color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Installation date: ' + props.dateright, {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Average temperature change: ' + props.mean_LST_diff.toFixed(2) + '°C', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Area: ' + props.area_hectare.toFixed(2) + ' hectares', {color: 'white', backgroundColor: '00000000'}))\n         .add(ui.Label('Potential population affected: ' + props.total_buffer_pop, {color: 'white', backgroundColor: '00000000'}))\n         .add(closeButton);\n  });\n});\n\n\n\nThis section implements a prediction interface for analyzing the impact of solar farms on temperature and population. The main features include:\n\nDrawing Tools: users can draw a polygon on the map to select an area of interest.\nPrediction Processing: the model calculates temperature and population changes based on the selected area.\nResults Display: the interface shows the predicted temperature change, potential population affected, and a detailed summary of the results.\n\n// Initialize default view\nshowPanel(visualizeContent, buttons.visualize, buttons.predict);\n\n// Add to UI root\nui.root.add(ui.Panel([mainPanel, map], ui.Panel.Layout.flow('horizontal'), \n  {width: '100%', height: '100%'}));\n\n// clear the predictedContent\npredictedContent.clear();\n\n// add a description label\npredictedContent.add(ui.Label('To explore the effects of building a solar farm in a new site, please click the button below and draw a polygon on the map. Please make sure you draw the panel over a fish farm.', \n  {fontSize: '14px', margin: '0 0 10px 0'}));\n\n//Add button to draw the polygons\nvar drawButton = ui.Button({\n  label: 'Draw a new solar farm',\n  onClick: function() {\n    // clear the previous drawing\n    map.drawingTools().layers().reset();\n    map.drawingTools().setShape('polygon');\n    map.drawingTools().draw();\n    \n    // Disable the draw button and prevent further drawing\n    drawButton.setDisabled(true);\n    \n    // Start drawing and disable the drawing tools until drawing is complete\n    map.drawingTools().setShown(false);\n  },\n  style: {margin: '0 0 10px 0'}\n});\npredictedContent.add(drawButton);\n\n// add a results panel\nvar resultsPanel = ui.Panel({\n  style: {\n    margin: '10px 0',\n    padding: '5px',\n    border: '1px solid #ddd',\n    backgroundColor: 'rgba(255, 255, 255, 0.8)',\n    shown: false\n  }\n});\npredictedContent.add(resultsPanel);\n\n// add a loading label to the predictedContent\nvar loadingLabel = ui.Label('Please wait while the model runs...', {\n  fontStyle: 'italic',\n  fontSize: '15px',\n  //color: '#1a73e8',\n  margin: '10px 0',\n  shown: false\n});\npredictedContent.add(loadingLabel);\n\n// Create a small text label to appear under the results panel\nvar modelInfo = ui.Label('Please be aware that although the model is a useful tool, its predictions are unlikely to be perfectly accurate. The model explains 79% of variation in temperature change, with an average error of approximately 0.33°C.', {\n\n  shown:false\n});\npredictedContent.add(modelInfo);\n\n// Modify the map drawing completion event processing\nmap.drawingTools().onDraw(function(geometry) {\n  resultsPanel.clear();\n  loadingLabel.style().set('shown', true);  // show the loading label\n  modelInfo.style().set('shown', false); //ensure model explanation and results panel are hidden, even if they were shown before\n  resultsPanel.style().set('shown', false);\n  \n  //Only run if there is some intersection with fishfarms\n  var intersection = fishfarms.filterBounds(geometry).size().gt(0);\n  \n  intersection.evaluate(function(intersects) {\n    if (intersects) {\n\n    //Slightly changed version of the original analysis - does all calculations simultaneously to reduce waiting time\n      var computeScale = 30;\n      var feature = ee.Feature(geometry);\n      var pop = popBuffer(feature); //run pop function from above\n      var now = ee.Date(Date.now());\n      var polygonStart = now.advance(-3, 'year');\n      var polygonEnd = now;\n      var currentImage = ee.Image(getLST(geometry, polygonStart, polygonEnd)); //run LST calculation from above\n      var allComputations = ee.Dictionary({});\n\n      // perform the calculations separately and merge the results\n      var lstDict = currentImage.select('LST').reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var indicesDict = currentImage.select(['NDVI', 'NDBI', 'FV', 'EM', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11']).reduceRegion({\n        reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n      var elevationDict = elevation.reduceRegion({reducer: ee.Reducer.mean(),geometry: geometry,scale: computeScale, maxPixels: 1e13});\n      var slopeDict = slope.reduceRegion({reducer: ee.Reducer.mean(), geometry: geometry, scale: computeScale, maxPixels: 1e13});\n\n      // Combine all the results\n      var combinedResults = ee.Dictionary(lstDict)\n        .combine(indicesDict)\n        .combine(elevationDict)\n        .combine(slopeDict)\n        .combine(pop.toDictionary(['total_buffer_pop', 'vulnerable_buffer_pop', 'child_buffer_pop', 'elderly_buffer_pop']));\n\n      combinedResults.evaluate(function(results) {\n        if (results.LST !== null) {\n          var currentLST = results.LST;\n          \n          //Create finished feature\n          var predictionFeature = ee.Feature(geometry, {\n            'NDVI': results.NDVI,\n            'NDBI': results.NDBI,\n            'B1': results.B1,\n            'B2': results.B2,\n            'B3': results.B3,\n            'B4': results.B4,\n            'B5': results.B5,\n            'B6': results.B6,\n            'B7': results.B7,\n            'B10': results.B10,\n            'B11': results.B11,\n            'elevation': results.elevation,\n            'slope': results.slope,\n            'area': geometry.area().divide(10000)});\n          \n          //Predict using model\n          var predicted = ee.FeatureCollection([predictionFeature]).classify(model);\n          predicted.first().get('classification').evaluate(function(futureTemp) {\n            var tempDiff = futureTemp - currentLST;\n            \n            //Hide loading label\n            loadingLabel.style().set('shown', false);\n            \n            //Print results\n            resultsPanel.style().set('shown', true);\n            resultsPanel.widgets().reset([ \n              ui.Label('Site Summary：', {fontWeight: 'bold', margin: '0 0 8px 0'}),\n              ui.Label('Current temperature：' + currentLST.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature with solar farm：' + futureTemp.toFixed(2) + '°C'),\n              ui.Label('Predicted temperature change：' + tempDiff.toFixed(2) + '°C'),\n              ui.Label('Potential population affected：' + (results.total_buffer_pop || 0) + ' people'),\n              ui.Label('Potential vulnerable population affected：' + (results.vulnerable_buffer_pop || 0) + ' people'),\n              ui.Label('Populations are calculated within 730m of the polygon. Vulnerable population refers to estimated numbers of children (0-5) and elderly (60+) individuals living within this area.', {\n                  fontSize: '12px', fontStyle: 'italic'})\n            ]);\n            modelInfo.style().set('shown', true); \n            drawButton.setDisabled(false);\n            \n          });\n        } else {\n          loadingLabel.style().set('shown', false);\n          resultsPanel.style().set('shown', true);\n          resultsPanel.add(ui.Label('There is insufficient satellite imagery to calculate temperature for this location. Please select a different area.'));\n          drawButton.setDisabled(false);\n        }\n      });\n    } else {\n      loadingLabel.style().set('shown', false);\n      resultsPanel.style().set('shown', true);\n      resultsPanel.add(ui.Label('This polygon does not intersect with any fish farms. Please redraw in a different location.'));\n      drawButton.setDisabled(false);\n    }\n\n    //Stop and hide drawing tools once processing is finished\n    map.drawingTools().stop();\n    map.drawingTools().setShown(false);\n  });\n});\n\n\n\n\nFinal app\nGithHub repository"
  },
  {
    "objectID": "solar_panel.html#references",
    "href": "solar_panel.html#references",
    "title": "CASA00025 Group Project: Assessing the Impact of the Photovoltaic Heat Island Effect on Fish Farms in Southeastern Taiwan",
    "section": "",
    "text": "Ballinger, O. (1 January 2024) Refinery Identification [Module content], Building Spatial Applications with Big Data CASA0025, University College London.\nGuoqing, L., Hernandez, R.R., Blackburn, G.A., Davies, G., Hunt, M., Whyatt, J.D. and Armstrong, A., 2021. Ground-mounted photovoltaic solar parks promote land surface cool islands in arid ecosystems. Renewable and Sustainable Energy Transition, 1, p.100008.\nHsiao, Y.J., Chen, J.L. and Huang, C.T., 2021. What are the challenges and opportunities in implementing Taiwan’s aquavoltaics policy? A roadmap for achieving symbiosis between small-scale aquaculture and photovoltaics. Energy Policy, 153, p.112264.\nŠafanda, J., 1999. Ground surface temperature as a function of slope angle and slope orientation and its effect on the subsurface temperature field. Tectonophysics, 306(3-4), pp.367-375.\nUSGS, 2019. Landsat 8 (L8) Data Users Handbook. Obtained from https://d9-wret.s3.us-west-2.amazonaws.com/assets/palladium/production/s3fs-public/atoms/files/LSDS-1574_L8_Data_Users_Handbook-v5.0.pdf\nXu, Z., Li, Y., Qin, Y. and Bach, E., 2024. A global assessment of the effects of solar farms on albedo, vegetation, and land surface temperature using remote sensing. Solar Energy, 268, p.112198. https://doi.org/10.1016/j.solener.2023.112198"
  }
]